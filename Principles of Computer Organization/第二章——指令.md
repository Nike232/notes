### 基础概念
*  指令与指令系统
* 存储程序概念

### 寄存器
32个32位寄存器(Smaller is faster)
32位->字
64位->双字
16位->半字

x22  基址寄存器
x0  硬连线到常数0（Make the common case fast）
x10-x17 八个参数寄存器，用于传递参数或者返回值
x1 返回地址寄存器，用于返回到起始点
x2 保存栈指针(sp stack pointer)
### 存储器（内存）
risc-v使用**字节寻址**
**小端编址**

### 有符号数与无符号数
有符号数求反：
x+~x=11111...=-1
所以-x=~x+1

符号拓展与逻辑拓展
**默认是符号拓展**
[![image.png](https://pic1.imgdb.cn/item/68e751f4c5157e1a885e91a4.png)](https://pic1.imgdb.cn/item/68e751f4c5157e1a885e91a4.png)
```
x11 0x3f5
index[0]=0xf5
index[1]=0x03 00000011
->x12 0x3
```
[![image.png](https://pic1.imgdb.cn/item/68e75282c5157e1a885e91f8.png)](https://pic1.imgdb.cn/item/68e75282c5157e1a885e91f8.png)
```
x11 0xfffff8f5 (符号拓展)拓展到32位
index[1]=0xf8
x12 0xfffffff8 符号拓展
```

### 基本算术运算
```
add a,b,c //a=b+c
sub a,b,c //a=b-c
```
加立即数:
`addi a,b,immediater`
### 数据传输指令
1.载入指令——将内存复制到寄存器
ld取双字(64位)
lw取字
`lw target_register 偏移量(基址寄存器)`
2.存储指令（store)——从寄存器复制数据到内存
sd
sw
`sw register 偏移量(基址寄存器)`

### 逻辑操作
[![image.png](https://pic1.imgdb.cn/item/68e758d3c5157e1a885e95b1.png)](https://pic1.imgdb.cn/item/68e758d3c5157e1a885e95b1.png)
注意：
1.可以通过与0xffff...进行异或实现NOT操作
2.左移相当于乘2的i次方
3.算术右移是用符号位填充，**相当于除以2的i次方，并向下取整**

指令写法：
```
slli x11,x18,4 //reg x11=reg x19 << 4
and x9,x10,x11 //reg x9=reg x10 & reg x11
```

### 用于决策的指令
#### 条件分支指令
1.beq指令——相等则分支
```
beq rs1,rs2,L1
```
如果rs1中的值等于rs2中的值，则跳转到L1的语句执行
2.bne指令——不等则分支
```
bne rs1,rs2,L1
```
**一般来说，测试相反的条件来进行跳转，代码将更有效率**
无条件分支
```
beq x0,x0,Exit //必定分支
```
3.blt指令——小于则分支
```
blt rs1,rs2,L1
```
如果rs1中的值比较小则跳转
4.bge指令——大于等于则分支
```
bge rs1,rs2,L1
```
如果rs1中的值不小于rs2中的值则跳转
**注意上面两条语句都是用二进制补码进行比较！**
5.无符号大于等于则分支语句——bgeu
边界检查的简便方法：
->边界检查的简便方法：无符号比较
```
x20>=x11或者x20是负数则跳转
bgeu x20,x11,L1
```

#### 循环
添加标签，跳转回去即可

### 函数(过程）调用
1.跳转-链接指令（jal）
```
jal x1,ProcedureAddress
```
第二个参数为立即数（相对距离）跳转到**当前地址+立即数这个地址**的同时，将下一条指令的地址保存到目标寄存器rd(x1)，x1中存放的是返回地址

jal指令实际上将PC+4保存在指定寄存器（通常为x1）中（因为一条指令为32位，4个字节）
无条件跳转:
```
jal x0,Label
```
由于x0硬连线0，效果为丢弃返回地址
2.jalr
```
jalr x1, x2, immediate
```
跳转到x2+immeidate并且把返回地址写在x1中
通常用于调用后返回地址（因为必须使用寄存器中的地址所以**返回只能用jalr）
```
jalr x0,0(x1)
```
压栈与弹栈
**栈按照从高到低的地址顺序增长**，也就是减栈指针压栈，增加栈指针弹栈

x5-x7以及x28-x31：临时寄存器，在过程调用中不被callee保存

x8-x9以及x18-x27:保存寄存器，必须被保存

帧指针

#### 内存布局
[![image.png](https://pic1.imgdb.cn/item/68e76406c5157e1a885eacbe.png)](https://pic1.imgdb.cn/item/68e76406c5157e1a885eacbe.png)
堆存放动态数据

### 大立即数
1.lui(load upper immediate)指令
用于将20位常数加载到寄存器的第31位到第12位，最左边的12位用0填充

[![image.png](https://pic1.imgdb.cn/item/68e76cabc5157e1a885ef44f.png)](https://pic1.imgdb.cn/item/68e76cabc5157e1a885ef44f.png)
分成两步完成
注意：由于加立即数的时候如果首位是1，那么会进行符号拓展，最后导致的结果是需要减去2的12次方，为了解决这个问题，**需要讲lui加载的常量添加1**


### 指令格式
1.R型
[![image.png](https://pic1.imgdb.cn/item/68e753c4c5157e1a885e92a8.png)](https://pic1.imgdb.cn/item/68e753c4c5157e1a885e92a8.png)
用于寄存器间的运算操作，包含一个目标寄存器和两个源寄存器
如add

2.I型
[![image.png](https://pic1.imgdb.cn/item/68e7543dc5157e1a885e92e2.png)](https://pic1.imgdb.cn/item/68e7543dc5157e1a885e92e2.png)
**注意：这里的立即数是12位的，但是基址寄存器是32位的，所以相加的时候立即数会默认先进行符号拓展！！！**
这里是一个源寄存器和一个目标寄存器
如addi

3.S型
[![image.png](https://pic1.imgdb.cn/item/68e7556ac5157e1a885e938e.png)](https://pic1.imgdb.cn/item/68e7556ac5157e1a885e938e.png)
这里是两个源寄存器——说明目标寄存器和源寄存器是不同的，比如目标寄存器需要写回，而源寄存器不用写回
如sw,lw

由于这里立即数是分两段存放，存放的规则是将立即数除以2的5次方也就是32，**高位的字段用于存放商，低位的字段用于存放余数**

三种指令格式的比较和记忆：

[![image.png](https://pic1.imgdb.cn/item/68e757f7c5157e1a885e9531.png)](https://pic1.imgdb.cn/item/68e757f7c5157e1a885e9531.png)
* 最右边都是7位的opcode
* 中间都是5位的rs1和3位的funct3
* 如果有目标寄存器，则在opcode旁边


4.SB型
[![image.png](https://pic1.imgdb.cn/item/68e76e4bc5157e1a885efc94.png)](https://pic1.imgdb.cn/item/68e76e4bc5157e1a885efc94.png)
和S型非常的类似，但是注意**这里imm是12-1**而不是之前的11-0的十二位，
也就是默认乘了一个2（为了兼容16比特也就是2字节长的指令）
如分支指令

5.UJ型
[![image.png](https://pic1.imgdb.cn/item/68e76f2ac5157e1a885f002d.png)](https://pic1.imgdb.cn/item/68e76f2ac5157e1a885f002d.png)

很特殊，只有一个目标寄存器，然后是20位的立即数
**和SB型一样，20-1**默认乘2
**jal是唯一使用UJ型的指令**

jalr使用I型

jal和jalr的对比：
[![image.png](https://pic1.imgdb.cn/item/68e7704ac5157e1a885f0613.png)](https://pic1.imgdb.cn/item/68e7704ac5157e1a885f0613.png)
#### 四种寻址模式
1.立即数寻址
2.寄存器寻址
3.基址寻址
4.PC相对寻址

