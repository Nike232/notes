### 加法和减法
减法是也是通过加法来实现的
```
x+~x=-1  (11111..)
所以-x=~x+1
```
硬件规模总是有限的，所以可能会发生溢出的情况

**当不同符号的操作数相加以及相同符号的操作数相减的时候一定不会发生溢出**
溢出条件就是**当结果的符号位发生了异常**

无符号溢出的情况：
如果总和小于加数的任何一个，则加法溢出；如果差大于被减数，则减法溢出。虽然无符号数的溢出很容易检测，但是无符号数通常使用自然数做地址运算，而程序通常不需要检测地址计算的溢出，所以这些溢出总被忽略。

### 乘法
如果忽略符号位，n位被乘数和m位乘数的积是n+m位的数

将乘数放在64位乘法器寄存器中，并将128位乘积寄存器初始化为0（因为64位x64位最多为128位）。

从实际的手算乘法中可以知道，计算过程中，被乘数每次左移一位（相当于x10），而乘数每次右移一位，所以被乘数放在128位被乘数寄存器中。一开始这个寄存器中右半部分是被乘数，左半部分全是0。然后该寄存器每执行一步便左移一位，然后将被乘数与128位的乘积寄存器中的中间结果对齐并相加到中间结果

**由于二进制计算只有0和1**，所以乘数的每一位如果是1的话就将被乘数加到结果当中，如果为0就跳过。

然后被乘数左移一位，乘数右移一位
[![image.png](https://pic1.imgdb.cn/item/68ee6d44c5157e1a88703763.png)](https://pic1.imgdb.cn/item/68ee6d44c5157e1a88703763.png)

进行改进：
[![image.png](https://pic1.imgdb.cn/item/68ee6d5fc5157e1a88703982.png)](https://pic1.imgdb.cn/item/68ee6d5fc5157e1a88703982.png)
也就是被乘数不动，一开始将乘数放在积的右侧，然后每次运算的结果放在积的前半部分，然后进行右移操作

当乘数是常数的时候，**可以用移位操作来代替乘法**

#### 带符号乘法
最简单的方法就是先把被乘数和乘数转换为正数，然后记住他们的符号，然后来操作

**可以直接将补码相乘，只要进行符号拓展**
也就是
` A补xB补=(AXB)补`

#### 快速乘法
其实就是实行并行运算，同时计算出每一位对应的结果，然后做加法

快速乘法可以通过为每一个乘数位提供一个64位加法器来实现，一个输入是被乘数与一个乘数位与的结构，另一个输入是上一个加法器的输出

一种方法是直接一个个连接，另一种如图

[![image.png](https://pic1.imgdb.cn/item/68ee734fc5157e1a88705fb2.png)](https://pic1.imgdb.cn/item/68ee734fc5157e1a88705fb2.png)

这种就变成了log2(64)，即6次加法

#### 指令
```
mul 获得64位积
mul 乘法取高位  获得128位积的高64位
mulhu 无符号乘法取高位 
mulhsu 有符号/无符号乘法取高位 一个有符号一个无符号
```
可以使用乘法高位指令来检查乘法的溢出，如果mulhu的结果为0，则没有溢出，如果mulh的结果所有位都是mul结果的符号位的复制，则没有溢出

### 除法


