动态规划一般是解决**最值问题**
核心思想还是穷举，但是动态规划是具有**最优子结构**的问题，也就是说这个问题的答案可以由其他的状态得到，所以必然会产生两种思维方式

第一种就是**自顶而下**的思维，就是把这个问题从上往下进行分解，一直到 base case最后就解决了。第二种自然就是**自低而上**的思维，就是从base case出发，逐步往上推，直到推出需要的问题。

其中很关键的一点就是**重复子问题**，就是一个问题被重复求了，这种就需要用备忘录来优化

这就是整个动态规划的一个基本的思路框架

很明显，动态规划的难点就在于**状态转移**，很多时候不知道怎么转移，**甚至很多时候根本没有想到状态还能转移**

好在，有一般的设计思路，那就是**数学归纳法**，其实设计转移方程，就是求递推公式一样，因为计算机做的就是穷举的事，所以我们自己拿到一个问题，首先想的就应该是最简单的情况，**看看最简单的情况可不可以直接得出答案**，**然后就是看其他情况能不能由简单或者下一级情况推出来**，如果能，那就是动态规划问题了，然后进一步按照数学归纳法，写出转移方程就可以了，直接看不一定能看出来，那么可以多写几个找规律就好了。

落实到代码当中，那其实最难的就是dp数组或者函数的定义，这个很关键，决定了能否推出答案。当然后面会具体讲解如何去定义。

下面先看一道题感受一下

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

	还是那句话，很多题你根本就没想过用动态规划，因为一眼很难看出来，所以要敢于尝试，**人类做题的过程其实就是dfs的过程**，这道题一看是求最值，就该想一想了，然后先不管那么多，先看base case那假如只有一个元素的数组是不是就已经出来了，那么如果是两个呢，是不是要拿第二个数跟第一个数比较，那如果有三个呢，那前两个是不是就已经得到答案了，第三个是不是与第一个第二个都去比较就好了，那么其实很自然的也可以知道dp的定义为以某个位置为止的最长子序列长度，然后递推就直接for循环去比较就可以了，当然别忘了最后要找整个数组的最大值，因为最大不一定是以最后一个元素结尾的！