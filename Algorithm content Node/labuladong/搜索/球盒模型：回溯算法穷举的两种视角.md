**回溯算法穷举的本质思维模式是【球盒模型】
球盒模型就是有两种穷举的视角，一种是球的视角另一种是盒的视角

### 排列
比如有n个球，k个盒子问一共有多少种放法？
第一我们可以从盒子的角度来思考，第一个盒子一定要放一个球，因而选一个，然后在剩下k-1个盒子里面放n-1个球

第二我们可以从球的角度来思考，那么比如对于第一个球，可以选可以不选，那就分成两种情况（加法原理），选的话就是选一个盒子，那么就是在n-1个球里面选k-1个盒子，如果不选就是在n个球里面选k个盒子

最后得到递归式都是一样的

### 组合
组合相比于排列，其实就是不在乎顺序，我只需要放进去就可以了，所以我们可以把所有的盒子都当做一个盒子，把这些球放进去就可以了

那么从盒子的角度来思考就是先选一个球，然后选第二个，但是注意这样会重复，比如选两个出来，第一次选1，第二次选2，跟第一次选2，第二次选1的效果是一样的，因为是不管顺序的，所以最后的结果要除以k

那如果是球的视角，那么每个球都是可以选择要不要放进盒子里面

### 全排列
之前的全排列写法外，还有一种swap写法
```cpp
class Solution
{
	vector<vector<int>>res;
	public:
	void traverse(vector<int>&nums,int start)
	{
		if(start==nums.size())
		{
			res.push_back(nums);
			return;
		}
		for(int i=start;i<nums.size();i++)
		{
			swap(nums,start,i);
			traverse(nums,start+1);
			swap(nums,start,i);
		}
	}
};
```
因为是全排列，所有的元素都必须要选，那么其实就是一个顺序问题 。很明显这个解法还是以盒的视角来写的，也就是每一个索引要装一个数，比如第一个索引能放所有的元素，那么就让所有的索引的数与第一个索引的数进行一个交换，这就做了一个选择了，然后去让下一个索引做选择（递归调用）,最后如果所有的索引的数都确定了，就添加到结果里面，最后别忘了撤销选择。

上面两种写法都是从盒的角度来写的，那么我们现在尝试从球的角度来写

很明显，所有的数就是球，最后要填满的数组就是盒，那么由于是全排列，所以我们所有的球都要选，那么对于每一个球而言，其实就是要挑一个没有使用过的索引填入

那么我们就要记录哪些索引用过了，哪些没有用过，当所有的索引都被用过的时候，就是一种排列的结果

```cpp
void traverse(vector<int>&nums)
{
	if(count==nums.size())
	{
		res.push_back(nums);
		return;
	}
	int originIndex=-1,swapIndex=-1;
	for(int i=0;i<nums.size();i++)
	{
		if(used[i])continue;
		if(originIndex==-1)
		{
			originIndex=i;
		}
		swapIndex=i;
		//做选择
		swap(nums,originIndex,swapIndex);
		used[swapIndex]=true;
		count++;
		//递归
		traverse(nums);
		//撤销选择
		used[swapIndex]=false;
		swap(nums,originIndex,swapIndex);
	}
	
}
```
这个是基于swap写法的思想，在数组原地进行交换以达到组合的目的。既然是以球的视角，那么被选择的对象就是数组中的索引，所以我们就是要找到空闲的索引，然后把球放进去。我们定义了一个originIndex和一个swapIndex,这个我们可以这样理解，因为我们是基于swap数组的，也就是交换球，那么其实我们可以认为原本每一个盒子已经放了球了。那么对于第一个索引里面的球，我们可以选择所有没有使用过的索引。

比如一开始originIndex就等于0，然后swapIndex就是从0到最后 ，其实就是第一个球选择索引的一个过程，那么选择其实在这里就是交换，然后让这个索引标记为已经使用过了，因为第一个球已经占了这个索引，然后再继续做选择，最后撤销选择就行了。

### 子集
之前我们已经见过了子集问题，这里以最简单的无重复不可复选的问题为例
```cpp
void traverse(vector<int>&nums,int start)
{
	res.push_back(trace);//每一个位置都构成一个子集
	for(int i=start;i<nums.size();i++)
	{
		//做选择
		trace.push_back(nums[i]);
		//然后递归
		traverse(nums,start+1);
		//撤销选择
		trace.pop_back();
	}
}
```
那么这个解法是以什么视角进行穷举的呢？

那么很明显，就是谁选择谁的问题，这里我们很明显是选择球，所以是以盒子的视角进行穷举的

那么能不能以球的视角写出代码呢？答案肯定是可以的，我们来尝试一下。

那其实原本我们按照盒子的视角来想的话，其实就是选哪些球放进入。那么我们如果按照球的视角来想的话，那么其实就是放不放进盒子里面，所以选择只有两个

```cpp
void traverse(vector<int>&nums,int i)
{
	if(i>=nums.size())
	{
		//所有选择已经做完
		res.push_back(trace);
		return;
	}
	//对nums[i]这个球进行抉择
	//第一种选择，放入
	trace.push_back(nums[i]);
	//然后递归
	traverse()
	//撤销选择
	trace.pop_back();
	//第二种选择 直接不选 让下一个球选
	traverse(nums,i+1);
}
```
