无论是排列组合还是子集问题，其实都是在一定规则下选择出需要的数，所以其实还是回溯思想来解决。
有几种形式：
**形式一、元素无重不可复选，即 `nums` 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式**。

以组合为例，如果输入 `nums = [2,3,6,7]`，和为 7 的组合应该只有 `[7]`。

**形式二、元素可重不可复选，即 `nums` 中的元素可以存在重复，每个元素最多只能被使用一次**。

以组合为例，如果输入 `nums = [2,5,2,1,2]`，和为 7 的组合应该有两种 `[2,2,2,1]` 和 `[5,2]`。

**形式三、元素无重可复选，即 `nums` 中的元素都是唯一的，每个元素可以被使用若干次**。

以组合为例，如果输入 `nums = [2,3,6,7]`，和为 7 的组合应该有两种 `[2,2,3]` 和 `[7]`。

### 子集、组合问题
首先是无重复不可复选
```cpp
class Solution {
private:
    vector<vector<int>> res;
    // 记录回溯算法的递归路径
    vector<int> track;

public:
    // 主函数
    vector<vector<int>> subsets(vector<int>& nums) {
        backtrack(nums, 0);
        return res;
    }

    // 回溯算法核心函数，遍历子集问题的回溯树
    void backtrack(vector<int>& nums, int start) {

        // 前序位置，每个节点的值都是一个子集
        res.push_back(track);

        // 回溯算法标准框架
        for (int i = start; i < nums.size(); i++) {
            // 做选择
            track.push_back(nums[i]);
            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            backtrack(nums, i + 1);
            // 撤销选择
            track.pop_back();
        }
    }
};
```
遍历到每一个节点的时候的trace都是一个子集应该收集，同时在起始索引中能做的选择就是比他大的，保证了不会重复。

子集问题是对于集合没有个数限制，而组合问题则是确定了格式所以很明显稍微改一下代码就可以了

**组合和子集是一样的：大小为 `k` 的组合就是大小为 `k` 的子集**。

排列问题我们在基本框架中已经讲过了，就不再重复了

#### 元素可以重复但不能复选
这里的子集我们默认是可以有重复元素的
比如输入 `nums = [1,2,2]`，你应该输出：
``[],[1],[2],[1,2],[2,2],[1,2,2] `
那么在遍历的时候，元素值相同的会出现同样的分支，因而我们要进行减枝，怎么做呢？
对于重复的元素的树枝，我们只遍历第一个就可以了，那么为了方便，我们先进行排序，这样可以轻松跳过相同的元素


那么对于有重复元素的排列问题，也是一样的思路，先进行排序，然后提前进行剪枝

但是有一点不同，全排列中所有的元素都必须是要选的，因而我们的去重其实是固定相同元素的位置，那么我们要做的就是，对于相同的元素，只有当前面的相同元素被选了之后才选我这个，这样就保证了相同元素的唯一顺序

### 元素没有重复但可以复选
对于子集或者是组合问题，我们原来的写法不能排除重复元素的关键在于，在调用的时候直接是调用的i+1,那么我们其实改为i，就可以做到重复元素了，但是要注意一个问题，就是base case，因为这颗二叉树毫无疑问会一直生长下去，那么我们需要终止条件，终止条件的选择应该不同题目不同分析，但是一定要记住这一点

那如果是对排列问题，我们之前就是用的used数组来去重，现在不用去重了，那还不简单？直接去掉used数组不就好了