### 括号生成
数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

有效的括号我们如果先生成再判断那肯定复杂度会很高，所以我们要提前判断

有两个重要性质：
**1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解**。

**2、对于一个「合法」的括号字符串组合 `p`，必然对于任何 `0 <= i < len(p)` 都有：子串 `p[0..i]` 中左括号的数量都大于或等于右括号的数量**。

特别是第二条可以供我们提前剪枝，剩下的就是直接套回溯框架了

### 集合划分
给定一个整数数组  `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

这道题很明显，非常精准的符合球盒模型，桶就是盒，树就是球，其实就是把这些个数放在这些桶里面，然后使他们的和都相同，由于给定一个数组，给定k，那么其实和就是一定的了。因此我们也是有两个思路来写，一种是球放进哪一个盒子里面，一种是盒子选择哪一个球

第一种思路：以球的视角
```cpp
class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        // 排除一些基本情况
        if (k > nums.size()) return false;
        int sum = 0;
        for (int v : nums) sum += v;
        if (sum % k != 0) return false;

        // k 个桶（集合），记录每个桶装的数字之和
        vector<int> bucket(k, 0);
        // 理论上每个桶（集合）中数字的和
        int target = sum / k;
        // 穷举，看看 nums 是否能划分成 k 个和为 target 的子集
        return backtrack(nums, 0, bucket, target);
    }

    // 递归穷举 nums 中的每个数字
    bool backtrack(vector<int>& nums, int index, vector<int>& bucket, int target) {

        if (index == nums.size()) {
            // 检查所有桶的数字之和是否都是 target
            for (int i = 0; i < bucket.size(); i++) {
                if (bucket[i] != target) {
                    return false;
                }
            }
            // nums 成功平分成 k 个子集
            return true;
        }
        
        // 穷举 nums[index] 可能装入的桶
        for (int i = 0; i < bucket.size(); i++) {
            // 剪枝，桶装装满了
            if (bucket[i] + nums[index] > target) {
                continue;
            }
            // 将 nums[index] 装入 bucket[i]
            bucket[i] += nums[index];
            // 递归穷举下一个数字的选择
            if (backtrack(nums, index + 1, bucket, target)) {
                return true;
            }
            // 撤销选择
            bucket[i] -= nums[index];
        }

        // nums[index] 装入哪个桶都不行
        return false;
    }
};
```

这个并不难理解，但是复杂度还是比较高的，不能通过所有的测试，所以我们尝试换一个视角

第二个思路：以桶的视角
```cpp
class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        // 见上文
    }

    bool backtrack(int k, int bucket, 
        vector<int>& nums, int start, vector<bool>& used, int target) {
        // base case
        if (k == 0) {
            // 所有桶都被装满了，而且 nums 一定全部用完了
            // 因为 target == sum / k
            return true;
        }
        if (bucket == target) {
            // 装满了当前桶，递归穷举下一个桶的选择
            // 让下一个桶从 nums[0] 开始选数字
            return backtrack(k - 1, 0 ,nums, 0, used, target);
        }

        // 从 start 开始向后探查有效的 nums[i] 装入当前桶
        for (int i = start; i < nums.size(); i++) {
            // 剪枝
            if (used[i]) {
                // nums[i] 已经被装入别的桶中
                continue;
            }
            if (nums[i] + bucket > target) {
                // 当前桶装不下 nums[i]
                continue;
            }
            // 做选择，将 nums[i] 装入当前桶中
            used[i] = true;
            bucket += nums[i];
            // 递归穷举下一个数字是否装入当前桶
            if (backtrack(k, bucket, nums, i + 1, used, target)) {
                return true;
            }
            // 撤销选择
            used[i] = false;
            bucket -= nums[i];
        }
        // 穷举了所有数字，都无法装满当前桶
        return false;
    }
};
```
这个是最基本的想法，但是复杂度很高，原因在于桶本来是没有区别的，但是这里的顺序导致有区别，导致了大量的重情况，但是可以注意到，这种情况下，used数组肯定长的是一样的，所以**可以用一个 `memo` 备忘录，在装满一个桶时记录当前 `used` 的状态，如果当前 `used` 的状态是曾经出现过的，那就不用再继续穷举，从而起到剪枝避免冗余计算的作用**。

那个这个memo备忘录怎么做呢？最直接的想法就是把used数组转化为string然后用哈希表，但是每次都要遍历一遍used数组还是很高。

这里注意到题目的数据规模：nums.length <= 16也就是说可以用一个整数来代替used数组，每一个位0和1的值就可以代替false和true

所以问题就大大简化了，在这个基础上剪枝就好了