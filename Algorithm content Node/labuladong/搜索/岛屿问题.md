首先岛屿问题是基本框架是dfs或者bfs遍历二维矩阵，而二维矩阵其实就是一种特殊的图，那么其实就是和图的遍历差不多（都需要visited数组）同时由于其特殊性，还可以把它看作一个四叉树，就是上下左右四个方向。

最简单的岛屿问题就是问岛屿的数量，其实就是遍历，然后如果遇到岛屿，就加一，然后用dfs把岛屿淹了(FloodFill 算法)

稍微改动一下，问封闭岛屿的数量，也就是靠岸的不算，很简单，先淹掉靠岸的就行了

再变形一下，要求求最大岛屿的面积，那么只需要在淹没岛屿的时候记录岛屿面积就可以了，直接给dfs加一个返回值

### 子岛屿
给你两个 `m x n` 的二进制矩阵 `grid1` 和 `grid2` ，它们只包含 `0` （表示水域）和 `1` （表示陆地）。一个 **岛屿** 是由 **四个方向** （水平或者竖直）上相邻的 `1` 组成的区域。任何矩阵以外的区域都视为水域。

如果 `grid2` 的一个岛屿，被 `grid1` 的一个岛屿 **完全** 包含，也就是说 `grid2` 中该岛屿的每一个格子都被 `grid1` 中同一个岛屿完全包含，那么我们称 `grid2` 中的这个岛屿为 **子岛屿** 。

请你返回 `grid2` 中 **子岛屿** 的 **数目**

关键问题肯定就在于如何判断是否是子岛屿，首先我们知道如果2中是岛屿对应的1中是水，那么肯定不是子岛屿，直接淹掉，那么剩下的就是子岛屿。

### 不同的岛屿
给定一个非空 01 二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 `1` 组成，你可以认为网格的四周被海水包围。

请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。

这道题非常的有意思，关键点肯定在于如何判断两个岛屿是否是重合的，根据我们之前的经验，很容易就可以想到用字符串序列化，作为一个岛屿的唯一标识。

在一开始我们提到了，二维数组可以看作是特殊的四叉树，那么这里就可以转化成多叉树的序列化的问题了，并且我们也采用的是递归的方式，那么就可以直接在递归中进行序列化，原本二叉树我们用l和r来做的，那么这里四个方向我们不妨用1234来做，然后如果离开就是负的值，这里一定要记录离开节点的值，不然会重复（因为无法区分层级关系）这样我们对每一个岛屿就得到了唯一的序列字符串，那么由于我们的扫描顺序是一定的，那么进入的节点的是一定的，那么重复的岛屿得到的序列就一定是一定的，那么我们用哈希集合来去重就可以了。