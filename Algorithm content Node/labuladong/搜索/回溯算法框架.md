回溯算法要站在遍历树的角度来思考，具体要思考三个问题：
1. 路径，就是我已经做出的选择
2. 选择列表，就是我当前有哪些可以选择
3. 结束条件，什么时候停止选择，或者说什么时候收集答案（ base case 首先考虑）

具体的例子可以想一想全排列
比如我要把1,2,3做全排列，那么现在我一开始是不是有三个选择，然后我选择一个，比如选1，然后我就可以选2，.......直到我已经选择了三个数，就得到了一个结果，当所有遍历完了也就得到了最后结果

回溯就是遍历树的过程，具体的代码我们也是依赖于树的遍历框架，也就是说，存在前序遍历和后序遍历两种（这里没有考虑中序遍历是因为其实很多情况下是多叉树）

**前序位置就是在刚到达节点之前运行，后序位置就是刚离开节点运行**

一般来说，我们在前序位置做选择，在后序位置撤销选择

「状态」「选择」和「base case」，就对应着走过的「路径」，当前的「选择列表」和「结束条件」


### 经典案例：数独和N皇后

解法就是穷举，数独就是每一个位置对树1-9进行穷举，这就是可选择的列表，规则是同一列和同一行以及九宫格内的数不重复。
N皇后就是对每一个位置进行穷举，本质上相当于取0还是取1，然后保证每一个行和每一列以及对角线上没有重复的1就可以了

先来一个简单的问题，给一个正整数n，穷举出长度为n的所有2进制数，我们马上可以构建出一个二叉树，结束条件就是二叉树的高度为n就可以了，所以对整个二叉树的遍历完就可以得到答案

每一个节点都是一个可能的选择，我们站在节点前对节点进行试探性的选择，看是否满足条件，然后递归执行，在离开节点的时候撤销选择

首先我们先来考虑数独问题
我们首先要做到的是将二维数组一维化，怎么做呢，其实很简单，本质上就是一个编码解码的问题。比如(i,j)对于一个Ｍ×Ｎ的数组，我们可以得到他的一维坐标为`i*N+j`这个是唯一的，同样的我们可以通过除法和取模得到二维坐标，

对回溯算法的剪枝优化，本质上就是寻找规则，提前排除不合法的选择，从而提高穷举的效率。

代码如下
```cpp
class Solution {
    // 标记是否已经找到可行解
    bool found = false;

public:
    void solveSudoku(vector<vector<char>>& board) {
        backtrack(board, 0);
    }

private:
    // 路径：board 中小于 index 的位置所填的数字
    // 选择列表：数字 1~9
    // 结束条件：整个 board 都填满数字
    void backtrack(vector<vector<char>>& board, int index) {
        int m = 9, n = 9;
        int i = index / n, j = index % n;

        if (found) {
            // 已经找到一个可行解，立即结束
            return;
        }

        if (index == m * n) {
            // 找到一个可行解，触发 base case
            found = true;
            return;
        }

        if (board[i][j] != '.') {
            // 如果有预设数字，不用我们穷举
            backtrack(board, index + 1);
            return;
        }

        for (char ch = '1'; ch <= '9'; ch++) {
            // 剪枝：如果遇到不合法的数字，就跳过
            if (!isValid(board, i, j, ch))
                continue;

            // 做选择
            board[i][j] = ch;

            backtrack(board, index + 1);
            if (found) {
                // 如果找到一个可行解，立即结束
                // 不要撤销选择，否则 board[i][j] 会被重置为 '.'
                return;
            }

            // 撤销选择
            board[i][j] = '.';
        }
    }

    // 判断是否可以在 (r, c) 位置放置数字 num
    bool isValid(vector<vector<char>>& board, int r, int c, char num) {
        for (int i = 0; i < 9; i++) {
            // 判断行是否存在重复
            if (board[r][i] == num) return false;
            // 判断列是否存在重复
            if (board[i][c] == num) return false;
            // 判断 3 x 3 方框是否存在重复
            if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == num)
                return false;
        }
        return true;
    }
};
```

N皇后问题，我们当然也可以像数独问题那样一个格子一个格子的去穷举，但是更好的方法其实是因为规定了每一行只可能有一个皇后，那么我们可以按照一行为单位进行列举，如果我们决定在 `board[i]` 这一行的某一列放置皇后，那么接下来就不用管 `board[i]` 这一行了，应该考虑 `board[i+1]` 这一行的皇后要放在哪里。