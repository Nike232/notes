### 内联函数
常规函数与内联函数的区别不在于编写方式，而在于c++编译器如何将它们组合到程序中。

普通函数是在调用的时候编译器生成调用指令，程序运行时跳转到对应函数

而内联函数是**在编译阶段，编译器直接将函数体复制到被调用处**，因此内联函数省去了函数调用的跳转和压栈开销。

好处是运行时间稍快，坏处是空间占用更多，如果有10处调用就有10个函数的副本，一般来说比较适合比较短小的函数

注意：**内联函数不能递归，也就是递归函数不能作为内联函数**

使用内联函数只需要在函数定义处加上`inline`关键字就可以了

如果函数原型和定义是分开的，最好两处都加，但是主要是看定义处。

通常的做法其实是省略原型，直接在原型位置写函数定义

```cpp
inline double square(double x){return x*x;}
```

与宏区分！！！
**宏是原始的文本替代**
```
#define SQUARE(x) x*x//这里甚至不能有;
```

案例->1.cpp

### 引用、临时变量
复习引用：引用就是**起别名**
**创建时必须初始化，并且不能更改关联的变量**

### 临时变量
临时变量就是编译器在某些表达式运算中**自动创建的、没有名字的变量**

```cpp
int a=3,b=4;
int c=a+b;//a+b的结果就是一个临时变量，赋值后立即销毁
```
a+b的结果是一个临时变量，然后被拷贝到c

```cpp
int func(int a,int b)
{
	return a+b;
}
int x=func(a+b);//func(a+b)返回的也是临时变量
```

```cpp
void func(double a);
int a=6;
func(a);//int->double不影响原来变量 原因就是会自动创建一个double类型的临时变量
```

#### 左值和右值
左值是**有名字、有地址、可以取地址**的对象，比如变量、数组元素、结构成员、指针

右值是**没有名字、无法取地址**的值，通常是临时变量、常量或者表达式结果

#### const引用
一般的引用必须是绑定变量，换句话说，只能绑定左值
```cpp
int func(int &a);
func(10);//错误的
```
```cpp
int func(const int&a);
int a=10;
func(a);
```
在这种情况下，在函数内使用a值是不能修改的

如果引用参数是const，则编译器在两种情况下可以生成临时变量(这个临时变量的生命周期延长到了直到函数结束)
* 实参的类型正确，但不是左值
* 实参的类型不正确，但是可以转换成正确的类型
案例->2.cpp

建议：应该尽可能使用const
理由：
* 可以避免数据被修改
* 能够处理左值和右值，泛用性比较强

#### 右值引用(c++11新特性)（了解）
原先的引用只能指向左值，c++11新增了右值引用，顾名思义，这种引用可指向右值，使用`&&`来声明

```cpp
int && ref=10;
```


### 引用作为函数返回值
```cpp
int & func();//返回一个int类型的引用
```
看似很不好理解，但我们只需要记住引用就是**别名**，所以这个函数调用就是一个变量的别名

案例->3.cpp

**不要返回一个局部变量的引用**
```cpp
int& func()
{
	int x=20;
	return x;
}
```
这种情况叫做悬空引用，会导致未定义行为

```cpp
class MyArray {
    int data[100];
public:
    int& operator[](int i) {
        return data[i];
    }
};
MyArray arr;
arr[3]=10;
```

```cpp
class Road {
    string path;
public:
    const string& getPath() const {
        return path;
    }
};
```
这个案例既提供了外部接口，又避免了每次调用的时候都复制，提高了效率，同时又避免修改，安全性高。

#### 值传递、指针传递、引用传递的选择
* 数据对象很小，比如内置数据类型或者很小的结构，值传递
* 数据对象为数组，指针传递（因为是唯一选择），如果不能修改+const
* 数据对象较大，使用const指针或者引用
* 数据对象为类，使用const引用。

### 默认参数

默认参数是指在调用函数时省略了实参时自动使用的一个值。
```cpp
void func(int a=1);
func();
```
**只在函数声明或定义中设置默认值**，不能两个同时设置默认值，否则会产生重复定义默认参数的错误

**必须从右向左添加默认值，也就是说，如果某个参数有默认值，那么它右边的所有参数都必须提供默认值**
```cpp
int func(int a,int b=4,int c=5);//合法
int func2(int a,int b=4,int c);//不合法
```
实参按从左到右的顺序依次被赋给相应的形参，**不能跳过任何参数**
下面的函数调用是不合法的
```cpp
func(3,,5);
```

### 函数重载
函数重载，允许在**同一个作用域中**定义 **多个函数名相同但参数不同**的函数。编译器根据参数的类型和数量来决定调用哪个函数。

特点就是：**函数名相同，但是参数列表不同**

- **参数个数不同**，或
    
- **参数类型不同**

	注意：**函数返回值类型不同不能构成重载**！

```cpp
int func(int a);
double func(int a);//不构成重载
```
有一些看上去是可以重载的，实际上是不行的，并不是**参数列表不同就一定能重载**

```cpp
int func(int a);
int func(int &a);//不能重载

int func(int a);
int func(const int a);//不能重载

int func(int &a);
int func(const int&a);//可以重载
//关键点其实在于两个在调用的时候能否有区别
//最后一个能重载的关键点在于非const变量赋值给const变量是合法的，但是const变量赋值给非const变量是非法的
```
案例->4.cpp

函数参数匹配的优先级：
1.精准匹配
2.隐式转换，隐式转换选择代价最小的，如果有多个代价相同，那么会造成歧义

**要注意默认参数可能导致歧义**
案例->5.cpp

### 函数模板
函数模板是 C++ 中的一种**泛型编程**手段，用来编写**类型无关的函数**。它可以让你用**一个模板函数定义**，来处理多种不同数据类型的输入，避免重复写多个类似的函数。

比如我们要写一个交换函数
```cpp
void swap(int &a,int &b)
{
	int temp=a;
	a=b;
	b=temp;
}
void swap(double &a,double &b)
{
	double temp=a;
	a=b;
	b=temp;
}
```
但是其实交换逻辑都是相同的，只是数据类型不一样。

函数模板便可以解决这个问题，可以节约编写程序的时间，使用还更加安全

```cpp
template <typename T>
//template <class T>
void swap(T &a,T &b)
{
	T temp=a;
	a=b;
	b=temp;
}
```
第一行建立一个模板，并将类型命名为T

注意**模板并不创建任何函数，只是告诉编译器如何定义函数**
需要交换int的函数的时候，编译器按照模板创建这样的函数，并用int代替T，同样double也是一样的

所以函数模板不能缩短可执行程序，最后还是生成了两个独立的函数定义，最后的代码也不包括任何的模板，只是生成函数的过程编译器去做了而已。

案例->6.cpp

#### 重载的模板
很多情况下，并非所有的类型都使用相同的算法，为了满足这个需求，可以像重载常规函数定义一样重载模板定义。同样参数列表需要不同

```cpp
template<typename T>
void func(T a,T b){...}
void func(T a[],int b){...}//注意并非所有的模板参数都必须是模板参数类型
```

函数模板肯定是存在一定的局限性，通常函数模板假定了可以执行哪些操作，但是对于一些类型是不适用的。

比如
```cpp
template <typename T>
void func(T a,T b){a=b;}
```
`a=b`对于数组类型肯定是不成立的

再比如对于`a<b`这种比较运算对某些结构体或者类来说是无法直接成立的，所以第一种方法就是在结构体或者类中重载运算符

第二种解决方法就是，为特定的类型提供具体化的模板定义

#### 显式具体化
显式具体化**是指为某个特定类型提供模板函数或类模板的**专门实现，以替代通用模板版本。

显式具体化是**是在模板的前提下的**，跟模板的定义要是一样的，只是数据类型换成了某种特定的数据类型

非模板函数就是平常定义的普通函数，跟模板没有关系

优先级：非模板函数>显式具体化>模板函数

显式具体化的原型和定义应该以template<>打头，并通过名称来指出类型
```cpp
template<typename T>
void func(T a){...}//模板函数
template<>
void func<int>(int a){...}//显式具体化
```
案例->7.cpp

#### 实例化
实例化分为隐式实例化和显式实例化

实例化就是根据模板产生一个函数实例

隐式实例化就是在调用模板函数的时候，编译器自动生成一个实例
```cpp
template <typename T>
void func(T a){...}
int a=10;
func(a);//在调用的时候产生一个实例这就是隐式实例化
```
所谓的显示实例化就是提前手动指定
```cpp
template void func<int>(int);
```

案例->8.cpp

显式实例化和显式具体化的区别：
* 显式实例化是告诉编译器在编译期间就根据模板对指定的数据类型生成一个实例
* 显式具体化是为了某一个类型重写一个版本，代替模板自动生成的那一个版本

隐式实例化、显式实例化和显式具体化统称为具体化

### auto与decltype

auto：
`auto` 让编译器根据初始化表达式自动推导变量的类型。
基本用法：
```cpp
auto 变量名=表达式;
```
auto 根据右边的表达式自动推断变量的类型

案例->9.cpp

注意：`auto` 默认会“值推导”，不保留引用和 const，除非显式加上 `&` 或 `const`。（引用是例外）

案例->10.cpp

decltype：
`decltype(expr)` ：**推导表达式 `expr` 的类型**，但**不对表达式求值**。

推导的是表达式的本质类型（会保留const &等）

案例->11.cpp

典型应用场景：
```cpp
template<class T1,class T2>
void func(T1 x,T2 y)
{
	decltype(x+y) z=x+y;
}
```
还可以结合typedef一起使用
```cpp
template<class T1,class T2>
void func(T1 x,T2 y)
{
	typedef decltype(x+y) xytp;
	xytp z=x+y;
}
```
#### 后置返回类型（c++11）
使用decltype可以知道一个表达式的类型，进而引用到模板中，但是函数的返回类型是decltype本身没有办法解决的。

```cpp
template<class T1,class T2>
???(decltpye(a+b)) func(T1 a,T2,b)
{
	return a+b;
}
```
同样我们无法预测到a+b得到的类型，如果将返回类型设置为decltype(a+b)是不对的，因为编译器还看不到他们。

为了解决这个问题，c++新增了一种声明和定义函数的方法

```cpp
double func(int a,float b);
```
新增的语法可以这样写
```cpp
auto func(int a,float b) -> double;
```
也就是将返回类型移到了参数声明的后面，其中auto这里是占位符，`->double`被称为后置返回类型

也可以用于函数定义
```cpp
auto func(int a,float b) ->double
{
	...
}
```

现在我们就可以解决之前的问题了
```cpp
template<class T1,class T2>
auto func(T1 a,T2 b) -> decltype(a+b)
{
	return a+b;
}
```
