### 数组
数组声明时的元素数目指定的值必须是常量（在编译时要是已知的），不能是变量（变量的值是在程序运行时设置的值）

下标、越界问题

#### 数组的初始化规则
1. 只有在定义的时候才能初始化
2. 提供的值可以少于数组的元素数目（剩余的自动赋值为default值）
3. 初始化时如果`[]`内为空，编译器将自动计算元素的个数
4. 使用统一初始化时，可以省略`=`比如`int arr[4]{1,3,4};`
5. 统一初始化不包含任何东西，将把所有元素设置为default值`int arr[4]{};`
6. 统一初始化禁止窄化转换

#### 动态数组vector
```cpp
#include <vector>
using namespace std;
vector<int> v1;                     
vector<int> v2(5);//5个默认值为0            
vector<int> v3(5, 42);// 5个值为42的元素
vector<int> v4 = {1, 2, 3, 4};// 列表初始化

```

| 操作     | 代码示例                         | 含义                          |
| ------ | ---------------------------- | --------------------------- |
| 添加元素   | `v.push_back(10);`           | 添加到末尾，自动扩容                  |
| 删除末尾元素 | `v.pop_back();`              | 删除最后一个元素                    |
| 访问元素   | `v[i]` or `v.at(i)`          | `at(i)` 会做越界检查              |
| 获取长度   | `v.size();`                  | 当前元素个数                      |
| 清空     | `v.clear();`                 | 清除所有元素                      |
| 判断空    | `v.empty();`                 | 是否为空                        |
| 插入元素   | `v.insert(v.begin()+1, 99);` | 插入到指定位置                     |
| 删除元素   | `v.erase(v.begin()+2);`      | 删除指定位置的元素                   |
| 排序     | `sort(v.begin(), v.end());`  | 排序（需 `#include<algorithm>`） |
### 字符串
#### C风格字符串(一种特殊的字符数组)
**以空字符`\0`结尾，用来标记字符串的结尾**
```cpp
char str1[3]={'a','b','c'};//不是字符串
char str2[4]={'a','b','c','\0'};//是字符串
```

将字符数组初始化为字符串可以用字符串字面值（字符串常量）

**字符串常量隐形包含\0**
在确定存储字符串所需的最短数组长度的时候，需要计算空字符，但是字符串长度计算（通过strlen计算）的时候是不包含结尾的空字符的

输入问题：
`cin>>s;`cin读取字符串的时候，是**按单词读入的**，也就是遇到空白（空格、制表符、换行符）的时候会停止
案例->1.cpp

解决：
1.使用`cin.get()`允许读入单个字符
```cpp
char s[50];
cin.get(s, 50);  // 读取直到遇到换行符或者最多读取 50 个字符
cout << s << endl;
```
2.使用`getline(cin,s);`来读取一行

```cpp
char str1[20];
string str2;

cin.get(str1,20);
cin.getline(str1,20);

getline(cin,str2);
```
#### cin.get()和getline()的区别

`cin.get()`是用来读取**单个字符**的，允许 **读取空格、制表符和换行符**，并且**换行符会保留在输入流中**

`getline()`是用来**读取一整行的**，包括空格，直到遇到换行符（**换行符会被丢弃**）
第三个参数可以加指定的分隔符

案例->2.cpp 3.cpp
### string类简要介绍
```cpp
//赋值
string s1="hello";
string s2=s1;//可以直接赋值

char str1[20]="hello";
char str2[20];
strcpy(str2,str1);//copy str1 to str2
//拼接
s2+=s1;

strcat(str2,str1);
```
其中strcat、strcpy可能会因为目标数组的长度过小出现问题

#### 字符串求长度
对于c风格的字符串，用`strlen()` O(n),从第一个字符开始数直到遇到\0
对于string 用`size()或者length()` O(1)


#### Raw(原始)字符串
`R("C:\User\tmp")`
常用于路径

### 结构体(自定义类型)
```cpp
struct stu
{
	int age;
	string name;
};
```
结构体使用要创建实例
```cpp
stu s1={8,"tom"};
```
通过`.`来访问成员

结构体是可以成员赋值的，也就是可以使用=将结构赋值给另一个同类型的结构体（即使成员是数组）
`stu s2=s1;//可以成员赋值`
案例->4.cpp

可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可
```cpp
struct stu
{
	int age;
	string name;
}s1,s2;
```
结构体有两种声明方式(了解）：可以内部声明（也就是在函数体内部进行声明）也可以外部声明（就是在函数外进行声明）（推荐）
内部声明，结构体就只能该函数使用，外部声明所有函数都可以使用

结构数组

#### 共用体（了解）
它与结构体（`struct`）相似，但有一个关键的区别：**共用体中的所有成员共享同一块内存空间**，而结构体中的每个成员都有自己的内存空间

**共用体**中的所有成员都会占用相同的内存位置，大小等于 **最大成员的大小**，所以无论你给哪个成员赋值，其他成员的值都会被覆盖，因为它们共用相同的内存。
	**共用体**中的所有成员都会占用相同的内存位置，大小等于 **最大成员的大小**，所以无论你给哪个成员赋值，其他成员的值都会被覆盖，因为它们共用相同的内存。

### 枚举类型(简单了解)
枚举类型其实就是为一些整数取别名，增加可读性
```cpp
enum Color { RED, GREEN, BLUE };
```
在默认情况下，会从0开始依次将整数值赋值给枚举量
也可以手动赋值
```cpp
enum Color {RED=3,GREEN=2,BLUE};
```
注意这里BLUE的值为3（允许枚举量的值相同）

使用枚举类型来创建变量：
```cpp
Color color;
```
在不强制类型转换的情况下，只能将定义枚举类型时使用的枚举量赋值给枚举变量
```cpp
color=RED;//valid
color=20000;//invalid
```
对于枚举，只定义了赋值运算符，没有为枚举定义算术运算
```cpp
color=RED;//valid
++color;//invalid
color=RED+BLUE;//invalid
```
枚举量是整型，可以被提升为 int类型，但是int类型不能自动转化为枚举类型
```cpp
int a=BLUE;//valid
a=RED+2;//valid
color=3;//invalid
```
虽然3对应的枚举量是RED，但是将3赋值给color将产生类型错误
如果int值是有效的，那么可以通过强制类型转换，赋值给枚举变量
```cpp
color=Color(3);
```
如果不有效，结果不确定

上述的所有规则实际上最终取决于实现，但是可以看出枚举的规则是非常严格的，所以实际上，**枚举被常用来定义相关的符号变量，而不是新的类型**，比如可以用枚举来定义switch语句总的符号常量。

如果只打算使用常量，而不创建枚举变量，那么可以省略枚举类型的名称
```cpp
enum {red,blue,yellow};
```

### 指针
#### 指针基础
指针是**存放某个变量地址的变量**
```cpp
int a = 10;
int* p = &a;
```
注:`int *`是一种复合类型，是指向int的指针
指针类型必须要是匹配的

常见的两个错误：
1.未初始化
```cpp
int a;a++;a=10;
int* p;*p=10;p=&a;
```
2.改变地址还是改变值
```cpp
int a;
int* p=&a;
*p=20;//改变的是a
int b;
p=&b;//改变的是p
```

#### 常量指针与指针常量
常量指针就是说指针指向的是一个常量的地址，因而解引用也就是使用这个常量的时候不能修改他的值
```cpp\
const int a=400;//常量在定义时必须初始化
const int* p=&a;
*p=299;//错误的
```

指针常量说的是指针是一个常量，也就是保持的值是一个常量不能修改
```cpp
int a=400;
int * const p=&a;//既然是一个常量，定义的时候必须初始化
int b;
p=&b;//错误，常量不能修改值
```

#### 指针与整数
**指针不是整型**，虽然计算机把地址当作整数来处理，但是从概念上来讲，指针和整数时两个截然不同的类型。
就比如两个地址相乘没有任何意义
```cpp
int *p=0xB8000000;//报错 int类型的值不能赋值给int*类型
int *p=(int *)0xB8000000;//可以的
```
案例->5.cpp

#### new和delete

1、创建单个变量
```cpp
int* p = new int;  // 在堆上开辟一个int
*p = 100;
cout << *p << endl;  
delete p;  // 释放内存
```
注意：
1. **delete释放的是p指向的内存，但不会删除p指针本身**
2. 一定要配对地使用new和delete；否则将发生内存泄漏
3. **不要尝试释放已经释放的内存块,然而，对空指针使用delete是安全的**
```cpp
int *p=new int;
delete p;
//delete p;//重复释放，会产生不可知的结果
p=null;//最好在释放后将指针指向null
delete p;//安全
```
对于第三点，因而在实践中，最好不要创建两个指向同一个内存块的指针

2、分配一个数组
```cpp
int* arr = new int[5];  // 开5个int的数组
for(int i = 0; i < 5; i++) arr[i] = i * 2;
for(int i = 0; i < 5; i++) cout << arr[i] << " ";
delete[] arr;  // 释放数组，要加[]
```
new的这里`[]`的值可以是变量
**释放时必须加上`[]`**

#### 指针、数组以及指针算术
将整数变量加1 后，其值将增加1；但将指针变量加1后，增加的量**等于它指向的类型的字节数。**

数组实际上一块连续内存

数组名是一个指针？
**数组名本身是数组类型**，但在大多数表达式中，**会被自动转换为指向首元素的指针**。

```cpp
int *p=new int [5];
int arr[5];
arr++;//错误的 因为数组类型根本就没有自增运算符
p++;//是允许的
```

所谓的索引访问元素，实际上就是利用了指针算术和数组连续存储的特性，通过首地址加偏移量来实现的（这也解释了为什么数组索引从0开始）

案例->6.cpp

注意：
1.解引用（`*`）的优先级低于加法(+)
2.解引用（`*`）和前置++一个级别（右结合）都低于后置++
```cpp
*++p;//先++然后解引用
++*p;//先解引用然后++
*p++;//先++然后解引用
(*p)++;//先解引用然后++
```
3.sizeof运算符用于数组名的时候返回的是整个数组的长度（字节为单位）
4.指针的加法和减法有意义，其他运算没有意义
5.字符串常量也被解释为字符串中第一个字符的地址
```cpp
char str[10]={'h','e','l','l','o','\0'};
cout<<str<<"world";
```
cout从字符的首地址开始打印，直到遇到\0为止

案例->7.cpp
tip：
	在将字符串读入程序时，应使用已分配的内存地址。该地址可以是数组名，也可以是使用new 初始化过的指针。（最好直接使用string）


#### 指针和结构体、类
**变量访问成员用`.`,指针访问用`->`
```cpp
struct Stu
{
	int age;
	string name;
}
Stu* p=new Stu;
(*p).age;
p->age;
```

