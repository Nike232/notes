### 运算符重载
之前已经了解过函数重载，运算符重载也就是将函数重载的概念拓展到运算符上。实际上之前已经接触过很多运算符重载的例子了，比如`*`运算符用于地址就是解引用，用于两个数字就是乘积。c++根据操作数的数目和类型来决定使用哪种操作

案例->1.cpp

#### 重载限制
1.重载后的运算符**必须至少有一个操作数是用户定义的类型**，这是防止用户为标准类型定义运算符，比如不能将-定义为求两个int的和

2.使用运算符的时候不能违反之前的句法规则，比如%是需要两个操作数，不能重载为只有一个操作数
**运算符的优先级不会被改变**

3.不能创建新的运算符，只能在已有的运算符中重载

4.有些运算符不能重载，常见的比如：`sizeof`、`.`、`::`、`?:`

5.大多数运算符可以通过成员或者非成员函数重载，但是下面的运算符只能通过成员函数重载
`=`赋值运算符
`()`函数调用运算符
`[]`下标运算符
`->`通过指针访问类成员的运算符

### 友元
通常，公有类方法提供了唯一的访问途径。但是有时候这种限制显得太严格，因而c++提供了另外一种形式的访问权限：友元

分为三种：友元函数、友元类、友元成员函数

这里先只介绍友元函数，通过让函数成为类的友元，就可以赋予函数与类的成员函数相同的访问权限

借用1.cpp中的例子来理解
假如现在需要重载`*`运算符，使得一个复数能够乘一个整数
```cpp
real operator*(const int a)
{
	return real(real_part*a,imag_part*a);
}
```
但是会产生一个问题就是，因为类中的重载运算符实际上是通过成员函数来调用的
比如
```cpp
real a(1.0,2.0);
real b=a*3;//实际上是b=a.operator*(3);
```
这种情况下下面的代码就是错误的
```cpp
real b=3*a;
```
所以如果这样做的话，就只能将a写在前面

为了解决这个问题，就只能使用非成员函数
```cpp
real operator*(int a,const real& b);
```
但是又出现了一个问题，那就是非成员函数不能直接访问类中的私有数据

所以这里就要使用友元函数

#### 创建友元
首先，**将原型放在类声明中，并在原型声明前加上关键字friend**

```cpp
friend real operator*(int a,const real&b);
```
虽然这个函数是在类声明中声明的，**但是它并不是成员函数，所以不能使用成员运算符来调用**，但是它与成员函数的访问权限是相同的

之后，编写函数定义。因为它不是成员函数，所以不要使用**类::来限定，在定义中也不要使用friend**

```cpp
real operator*(int a,const real&b)
{
	real c;
	c.real_part=a*b.real_part;
	c.imag_part=a*b.imag_part;
	return c;
}
```
有了上述的声明和定义
```cpp
real b(1.2,3.4);
real c=5*b;//相当于c=operator*(5,b);
```

当然如果仅仅是为了使得交换顺序成立其实可以不使用友元函数，可以这样做
```cpp
real operator*(int a,const real&b)
{
	return b*a;//调用成员函数
}
```

#### 常用的友元：重载<<运算符
首先要明确的是ostream是一个类，cout是ostream对象，cout能识别所有基本类型的原因是，对于每一个基本类型，ostream类声明中都包含了相应的重载operator<<()的定义。

如果要让cout能识别我们自己创建的类，一种方法是将新的重载添加到ostream，但是修改iostream文件是非常危险的。

但是又要能访问到我们自定义类中的数据，也就是如果作为成员函数的话，只能是这样写xxx<<cout但是这非常的奇怪

所以我们可以使用友元函数
```cpp
class Stu
{
	string name;
	int age;
	public:
	Stu(){}
	Stu(string n,int a){name=n;age=a;}
	friend void operator<<(ostream&os,const Stu&s);
};
void operator<<(ostream&os,const Stu&s)
{
	os<<s.name<<" "<<s.age;
}
int main()
{
	Stu s("John",18);
	cout<<s;
}
```

注意友元函数是为了方便访问类中的成员或数据，这里我们只需要访问Stu类中的数据，所以它一定是Stu的友元，但是不必要访问ostream中的数据，所以不必修改ostream中的定义

但是上面的实现有一个问题  比如下面的代码就无法正常运行
```cpp
cout<<"Hello"<<s<<"Welcome";
```
关于为什么不可行，我们先看简单的例子
```cpp
int a=10,b=20;
cout<<a<<b;
```
第二行代码其实等价于`(cout<<a)<<b;`
<<运算符左边是一个ostream对象，这里是cout
所以其实(cout<<a)是一个ostream对象，也就是说ostream类将operator<<()函数实现为一个返回指向ostream对象的引用

这也就解释了为什么上面的代码行不通，那实际上`cout<<"Hello"<<s;`是可以的，但是因为我们上面实现的返回值是void，所以导致后面的代码出错，所以只需要稍微修改一下代码就可以了

案例->2.cpp

### 类的自动转换和强制类型转换
当一个类的构造函数只有一个参数的时候，或者说只有一个没有默认值的参数的时候，c++会自动进行隐式类型转换。
```cpp
class A
{
	public:
	A(int a){/**/}
};
int main()
{
	A a=10;//触发隐式转换，实际上是调用构造函数
}
```
也可以有多个参数，只要只有一个参数没有默认值就可以
比如`A(int a,double b=20){}`

在构造函数前面加上explicit关键字可以关闭这个自动转换

案例->3.cpp 4.cpp

#### 转换函数
可以把基本类型转换为类，但是如何把类类型转换为基本数据类型呢？
这就要使用转换函数，它是一种特殊的成员函数，可以将类的对象转换为另一种类型（通常是基本数据类型或者其他类类型）

```cpp
operator 类型();
```
这里的类型是想要转换成的目标类型，转换函数没有返回类型，也没有参数，它的作用就是提供类型转换的机制

实例：将一个复数类型转换为double类型（取实部）

案例->5.cpp

可以显式调用也可以隐式调用
```cpp
Complex c;
cout<<double(c);//显式调用
double a=c;//隐式调用
```

但是要注意二义性
假如同时定义了转换成int和double的转换函数
```cpp
long a=c;//出现错误
```
因为int和double都可以赋值给long变量，所以编译器使用任何一个转换函数都是合法的，所以会出现二义性。但是显式调用依然是可以的
```cpp
long a=(double)c;
long a=int(c);//都是合法的
```

需要注意，**应该尽量避免隐式转换，最好使用显示转换**
同样可以在转换函数前加上explicit关键字关闭隐式转换

