### 面向过程和面向对象编程
面向过程编程首先考虑的是要遵顼的步骤，然后考虑如何表示这些数据，然后根据整个流程创建函数来实现

面向对象编程首先要从用户的角度考虑对象（所需的数据和描述用户和数据之间交互所需要的操作），然后设计好接口和数据存储，最后设计出程序

oop(面向对象编程)的**四大特性：封装、继承、多态、抽象**
### 类和对象基本知识
类其实就是用户自定义出来的一种**数据类型**，包含了数据和可能的行为(用函数来实现）。同时类还具有一定的抽象性，"一类事物"

对象就是根据类创建的一个实例，是一个具体的事物。就和int和变量a的关系是类似的

一般来说，类由两个部分组成：类定义(描述数据成员和函数)
和类方法定义(描述如何实现成员函数)

类定义通常放在头文件中，类方法定义通常放在源文件中。

#### 访问控制
一共有三种：private、public、protected

|权限|含义|可被访问的范围|
|---|---|---|
|`public`|公有成员，**所有地方都能访问**|类外部、成员函数、子类|
|`protected`|受保护成员，**类内和子类能访问**|类内部和派生类|
|`private`|私有成员，**只能在类的内部访问**|只有当前类的成员函数可访问|

**类的内部能访问所有成员，但是类外部只能访问public成员**，至于类之间的关系，之后会慢慢提到

一般来说，要防止程序直接访问数据，这个称为数据隐藏，**因而一般将数据设置为private**

**类对象默认访问控制是private**
```cpp
class Std
{
	string name;//默认是private
	public:
	void showname();//成员函数的声明
}
```
关于成员函数：
如果是对外的接口，应该设置为public，如果不是最好写成private

成员函数可以直接在类定义中直接定义（但是不推荐，除非是极其简短的函数），另一种也是推荐的做法是在类中写函数声明，在其他地方比如源文件写函数实现（这时候要用：：来指明是哪一个类中的函数）

**定义在类定义中的函数都将自动成为内联函数**
案例->1.cpp

像创建变量一样创建对象：
```cpp
class Stu
{
	int age;
	public:
	string name;
	int getAge(){return age;}
};
int main()
{
	Stu s;
	s.getAge();
	s.name="hello";
	Stu *p=s;
	p->name="world";
	p->getAge();
}
```
**对象名访问用`.`，指针访问用`->`**

所创建的每一个新的对象都有自己的存储空间，用于存储其内部变量和类成员；但是同一个类的所有对象都共用一组类方法，也就是每种方法只有一个副本

### 构造函数和析构函数
首先类没有办法像一般变量一样直接初始化，并且类有一个特征是类的数据大多数是私有的，也就是外部无法访问。所以只有通过函数来实现，但是并不能保证外部在创建对象的时候一定会调用这个初始化函数，所以c++提供了一个特殊的成员函数，也就是构造函数。

**构造函数的特点**：
1.**与类同名**
2.**没有返回值（没有返回类型）**
3.**自动调用**
4.**可以重载**

构造函数是一种特殊的成员函数，但是也是成员函数，因而也存在访问控制，private、public、protected，先阶段，先把构造函数写成public

```cpp
class Stu
{
    int age;
	public:
	Stu(int a){age=a;}
};
```
有两种方式来使用构造函数：
1.显式调用构造函数`Stu s=Stu(18);`
2.隐式调用构造函数`Stu s(18);`
`Stu *p=new Stu(18);`
每次创建类对象（包括使用new动态分配内存的时候），C++都会使用类构造函数

**构造函数不能通过对象被调用**
```cpp
Sut s;
s.(18);//错误的
```

#### 默认构造函数
默认构造函数就是当没有提供任何显示初始值的时候，用来创建对象的构造函数
```cpp
Stu s;//其实调用的就是默认构造函数
```
**如果没有提供任何构造函数，C++将自动提供默认构造函数（不做任何工作），但是如果提供了构造函数，就必须要求提供默认构造函数**

也就是说，如果提供了非默认构造函数，但是却没有提供默认构造函数，`Stu s;`这种声明就会报错

这种情况下，就必须要定义一个**不接受任何参数的默认构造函数**

定义默认构造函数的方式有两种：一种是给已有的重载构造函数的所有参数提供默认值，另一种是写一个没有参数的构造函数

由于**只能有一个默认构造函数**，所以两种方法不要同时使用

案例->2.cpp

**隐式地调用默认构造函数的时候，不要用圆括号，不然会以为在定义函数**
```cpp
Stu s();//错误的 不要使用()
```

#### 列表初始化
列表初始化也可以应用在创建对象，本质上也是在调用构造函数。
```cpp
Stu s1{18};
Stu s2{};//调用默认构造函数
```
#### 析构函数
构造函数是用于创建对象的时候进行初始化，析构函数则是在对象生命周期结束的时候释放资源，完成清理工作。

比如如果构造函数使用new来分配内存，那么析构函数将使用delete来释放内存。

**析构函数的特点：**
1.`~`＋类名
2.没有返回值（没有返回类型）
3.不能有参数
4.**不能重载**也就是一个类只能有一个析构函数

可以手动调用析构函数，但是一般不建议。一般情况下，对象的声明周期结束的时候，会自动调用析构函数

### const成员函数
先看这样一段代码
```cpp
class Stu
{
	int age;
	public:
	Stu(){}
	Stu(int a){age=a;}
	void showage(){cout<<age;}
};
int main()
{
	const Stu s{18};
	//s.showage();
}
```
创建了一个const对象，但是在调用成员函数的时候，也就是注释掉的这行代码却会报错。

原因在于const对象的值是不能修改的，但是调用普通的成员函数无法确保被调用的函数不会修改对象，所以会报错

在之前的普通函数当中我们是通过在参数中加上const防止参数被修改来解决的，但是这里很明显不能这样做。

C++的解决办法是**将const关键字放在函数的括号后面**，这种成员函数叫做const成员函数，**注意这样就不能在函数中修改数据**

案例->3.cpp

### this指针
先看一个案例
如何实现两个学生根据年龄来比较，返回较大年龄者的对象的成员函数
```cpp
class Stu
{
	int age;
	public:
	Stu(int a){age=a;}
	Stu(){}
	const Stu & cmp_age(const Stu &other)
	{
		...
	}
};
```
参数上使用了const修饰符来防止被对象被修改，然后返回值选择了引用的方式，一方面防止被修改，同时减少了内存复制带来的开销

下面来看函数实现
```cpp
if(age<=other.age)return other;
else return ???;
```
很明显如果我们要返回自身这个对象，目前是做不到的，所以C++的解决办法使用，使用被称为this的特殊指针。**this指针指向用来调用成员函数的对象**（this被作为隐藏参数传递给方法）

`*this`也即是这个对象

上面的表达式就可以写成`else return *this`

### 对象数组
```cpp
Stu arr[4];
```
创建一个Stu类的数组，每一个元素都是一个对象
```cpp
arr[0].showAge();
```
之前说过，当创建对象但是没有显式初始化时，将调用默认构造函数，也就是例子中数组的四个元素都是使用默认构造函数构造出来的

当然也可以使用构造函数来初始化数组，这种情况下，就必须为每个元素调用构造函数
```cpp
Stu arr[4]={Stu(28),Stu(20),Stu(18),Stu(19)};
```
```cpp
Stu arr[4]={Stu(20),Stu()};
```
### 类作用域
之前介绍了全局作用域和局部作用域，c++引入了一种新的作用域：类作用域

在类中定义的名称（包括数据和函数）的作用域都是整个类，也就是只在该类中该名称是可知的，类外是不可知的。所以，可以在不同的类中使用相同的名称，而且外部也不能直接访问类的成员（即使是公有成员函数），只有通过对象才能调用。

#### 作用域为类的常量
在很多时候类中需要一个常量，比如数组的最大长度等等
```cpp
class Stu
{
	const int max_subject=10;
	int subjects[max_subject];
};
```
这样看上去是正确的，但是实际上是错误的

原因在于类只是描述对象的组织形式，**但是并没有创建对象**，所以max_subject实际上还没有分配内存，要在创建对象之后，每一个对象的存储空间中才存着一个max_subject

而且这同样暴露出一个问题，就是每一个对象都会有一份常量的拷贝，但是实际上，常量反正是不能修改的，所以其实只需要一份拷贝就够了

所以c++提供了一种在类中定义常量的方式，使用static关键字
```cpp
class Stu
{
	static const int max_subject=10;
	int subjects[max_subject];
};
```
用这种方式，常量就不是存储在对象之中了，而且所有对象都是共享这一个常量。

之后将详细介绍静态类成员

