### 动态内存和类
从一个案例中学习在类中使用动态内存
```cpp
class stringbad
{
	private:
	char *str;
	int len;
	static int num_strings;
	public:
	stringbad(const char*s);
	stringbad();
	~stringbad();
	friend ostream & operator<<(ostream& os,const stringbad&st);
};
```
定义了一个类 char`*`用来存放字符串，因为长度不确定，所以才用指针。然后用len表示字符串的长度，设置了static变量，用来表示所有字符串的个数。注意static变量是所有对象共有的。

接下来看stringbad.cpp中的代码

```cpp
int stringbad::num_strings=0;
```
这条语句将静态成员num_strings的值初始化为0。**注意不能在类声明中初始化静态成员变量，因为声明只描述了如何分配内存，但是并不分配内存**，对于静态类成员，可以在类声明之外用单独的语句进行初始化，因为它并不是对象的组成部分。（但如果静态成员是const，则可以在类声明中国进行初始化）

注意初始化是在cpp文件中，而不是在头文件中，不然会有多个初始化语句的副本，导致错误。

```cpp
stringbad::stringbad(const char*s)
{
    len =strlen(s);
    str=new char[len+1];//分配内存 注意\0
    strcpy(str,s);//复制内容 注意不能写成str=s;
    num_strings++;
}
stringbad::stringbad(){}
stringbad::~stringbad()
{
    --num_strings;
    delete []str;//注意[]
}
ostream& operator<<(ostream& os,const stringbad &st)//友元函数
{
    os<<st.str;
    return os;
}
```

main.cpp中的代码：
```cpp
void func1(stringbad s)
{
    cout<<"func1:"<<s<<endl;
}
void func2(stringbad &s)
{
    cout<<"func2:"<<endl;
}
int main()
{
    stringbad s1("Hello");
    cout<<"s1:"<<s1<<endl;
    cout<<"Number of strings: "<<stringbad::num_strings<<endl;
    stringbad s2("World");
    cout<<"s2:"<<s2<<endl;
    cout<<"Number of strings: "<<stringbad::num_strings<<endl;
    func1(s1);
    cout<<"After func1, Number of strings: "<<stringbad::num_strings<<endl;
    func2(s2);
    cout<<"After func2, Number of strings: "<<stringbad::num_strings<<endl;
    return 0;
}
```
运行结果：
[![image.png](https://pic1.imgdb.cn/item/689964d958cb8da5c8185457.png)](https://pic1.imgdb.cn/item/689964d958cb8da5c8185457.png)
案例->1

可以发现func1出现了问题，func2没有什么问题，func1和2的区别在于一个是值传递，一个是地址传递。
func1会创建一个临时对象s
```cpp
stringbad s=s1;
```
首先介绍一下，c++一般可以自动提供下面这些成员函数（在没有定义的情况下）：
1.默认构造函数
2.默认析构函数
3.复制构造函数
4.赋值运算符
5.地址运算符

复制构造函数用于将一个对象复制到新创建的对象当中，也就是说，它**用于初始化过程中，而不是赋值过程中，因为我们之前说过复制构造函数不能在后面手动调用**

复制构造函数的原型一般如下：
```cpp
Class_name(const Class_name&);
```

什么时候调用复制构造函数？新建一个对象并且将这个对象显式地初始化为一个现有的对象
比如下面几种情况：
```cpp
stringbad s1(s);
stringbad s1=s;
stringbad s1=stringbad(s);
stringbad *p=new stringbad(s);
```
每当程序产生了对象的副本的时候，编译器都将使用复制构造函数。比如函数用值传递对象，函数返回值为对象的时候。

**在没有编写复制构造函数的时候，编译器将自动生成一个默认的复制构造函数，它逐个复制非静态成员，复制的是成员的值，所以这种方式又叫浅拷贝**

所以上面的例子，编译器自动生成的复制构造函数大概是这样的：
```cpp
stringbad(const stringbad&other)
{
	str=other.str;
	len=other.len;
	//注意静态变量属于整个类
}
```
所以可以发现临时变量和原变量的str指向了同一块内存！！！
但是func1函数运行完毕的时候，会销毁临时变量，所以会执行析构函数，因而原来变量的str指向的地址已经被释放掉了，并且num_strings也已经执行了--的操作

 如何解决?定义一个显示复制构造函数

案例->2

**如果类中包含了new初始化的指针成员，应该显式定义个复制构造函数，以复制指向的数据，而不是指针，这种复制叫做深拷贝，相反，如果只是复制指针值，这种复制被叫做浅拷贝**


#### 赋值运算符的问题
C++中允许类对象赋值，这是通过自动为类重载赋值运算符实现的。
```cpp
class_name & class_name::operator=(const class_name &);
```

那么针对上面的问题，就算已经显式定义了复制构造函数，下面的代码还是会出现浅拷贝的问题
```cpp
stringbad a;
a=b;
```
这里用的就不是复制构造函数了，因为构造函数只能在变量初始化的时候才会自动调用，所以这里是用的重载赋值运算符，所以如果没有显示定义的话，还是会出现浅拷贝的问题。

一个比较好的自定义的string的案例->3

#### 使用中括号来访问字符
```cpp
char & operator[](int i)
{
	return str[i];
}
```
这样又可以读取又可以修改，但是对于`const String s;`就无法执行这个函数，这种情况下可以再定义一个加上const的成员函数

**注意const是函数签名的一部分，所以这里是可以重载的，对于非const成员会优先调用非const成员函数，对于const成员，只能调用const成员函数**

```cpp
const char& operator[](int i)const
{
	return str[i];
}
```

### 静态类成员函数
可以将成员函数定义为静态的（注意函数声明中必须包含关键字static，但是如果函数定义是单独的，那么定义不能包含static）

这样做的结果有两个：
第一：就像静态变量属于整个类一样，静态成员函数也是属于整个类的，所以静态成员函数不能使用this指针

第二：由于静态成员函数不和特定的对象相关联，**所以只能访问静态成员**
这个例子中，如果定义一个静态成员函数，那么它只能访问num_strings，而不能访问str,len等等

### 在构造函数中使用new的注意事项
1.new和delete对应并且匹配
2.如果有多个构造函数，则必须用相同的方式使用new,要么都带`[]`要么都不带，**因为只有一个析构函数，所以所有的构造函数都必须与它兼容**
3.复制一定要注意是深拷贝还是浅拷贝，如果是深拷贝，则要自己定义复制构造函数和重载赋值运算符



