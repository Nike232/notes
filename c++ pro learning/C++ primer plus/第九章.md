### 多文件编写和编译
#### c++程序的构建过程
```cpp
源代码(.cpp/.h)
   ↓（1. 预处理）
预处理文件(.i)
   ↓（2. 编译）
汇编代码(.s)
   ↓（3. 汇编）
目标文件(.o / .obj)
   ↓（4. 链接）
可执行文件(.exe / a.out)
```
1.预处理阶段->删除注释、处理#include、宏替换、条件编译

2.编译阶段->翻译成汇编语言、类型检查

3.汇编阶段->转为二进制机器码，生成目标文件

4.链接阶段->将多个目标文件合并成一个可执行文件

#### 文件分类
* 头文件：编写原型和声明
* 源文件：编写实现

#### “”和<>
```cpp
#include "xxx.h"
#include <xxx>
```
`""`--**用于自己的头文件**
会**先**在当前源文件所在的目录下找 `xxx.h`，如果找不到，再去标准头文件路径里查找
`<>`--**用于标准头文件或者第三方库**
-只在标准头文件路径（例如 `/usr/include`）里查找，不会在当前目录查找

#### 头文件管理
在同一个文件中只能将同一个头文件包含一次

但是可能在不知情的情况下将头文件包含多次，比如使用了包含了另一个头文件的头文件。

为了避免多次包含同一个头文件，可以使用预编译指令#ifndef(`if not defined`)
```cpp
#ifndef TEST_H
...
#endif
```
只有没有定义TEST_H的时候才处理中间的语句

```cpp
#ifndef TEST_H
#define TEST_H
...
#endif
```
在编译器首次遇到这个文件的时候，TEST_H还没有定义(这里的名称是我们自己定的，一般使用文件名_H的形式，以创建一个其他地方不太可能被定义的名称)

注意，这种方法事实上并不能防止编译器将文件包含两次，但是可以让他忽略除了第一次包含之外的所有内容

如果在一个文件中定义两次，会导致编译错误

案例->1


### 内存模型
```vbnet
          ┌────────────┐
   高地址 │   栈 Stack  │ ← 局部变量、函数参数
          ├────────────┤
          │   堆 Heap   │ ← new 分配的数据
          ├────────────┤
          │ 静态/全局区 │ ← static/global变量
          ├────────────┤
          │  代码区 Text│ ← 程序指令
   低地址 └────────────┘

```

## 存储方式
主要是自动存储和静态存储

不同的存储类型有各自的作用域和链接性
### 作用域和链接性
作用域描述的是一个标识符（比如变量、函数、类等）在哪些代码区域内是可见的、可使用的。

比如作用域为局部的变量就只能在定义它的代码块中使用。作用域为全局的变量在定义位置到文件结尾都可以使用。

链接性指的是一个名字（变量、函数等）是否能被其他翻译单元（源文件）访问到，也就是在**不同的文件(单元）**中是否能共享。

| 链接性       | 说明                                        |
| --------- | ----------------------------------------- |
| **无链接性**  | 名字只能在**当前作用域**使用，例如：局部变量。                 |
| **内部链接性** | 名字在**当前文件中可见**，其他文件不可见。通常通过 `static` 实现。  |
| **外部链接性** | 名字可以被**多个文件共享和访问**。默认情况下，全局变量和函数都具有外部链接性。 |

### 自动存储类型

- **创建时间：** 当程序的执行**进入其作用域**（即函数或块体）时自动创建；
- **销毁时间：** 当程序的执行**离开其作用域**时自动销毁；
#### 普通局部变量
**在默认情况下，在函数中声明的函数参数和变量都是普通局部变量，作用域为局部，没有链接性**

```cpp
void func()
{
	int a;
}
int main()
{
	int a;
	for(int i=0;i<0;i++)
	{
		int b;
	}
}
```
执行到代码块的时候分配内存，当代码块结束的时候，变量被销毁

**如果有两个同名的变量（一个位于外部代码块中，另一个位于内部代码块中），在执行内部代码块中的语句时，新的定义会隐藏之前的定义**，也就是新定义可见，旧定义暂时不可见，在程序离开该代码块的时候，原来的定义又重新可见了

案例->2.cpp

补：
	在c++11之前，auto被用于指定变量为自动存储类型，`auto int a;`但是几乎没有用，所以在c++11中，auto现在被用于自动推断类型


常用的管理自动变量的方法是留出一段内存，并将其视作为**栈**，来管理变量的增减。

#### 寄存器变量
使用register关键字
```cpp
register int a;
```
告诉编译器希望把它放在**CPU 的寄存器中**而不是内存中，以提高访问速度(但是编译器可以选择忽略)

目前已经被弃用

### 静态存储类型

**生命周期为整个程序运行期间**

**只要是静态存储类型的变量，在没有手动初始化的情况下都会被自动初始化（默认值）**

可以有三种链接性

外部链接性（全局变量也叫外部变量）：
```cpp
int global=1000;//全局变量 静态存储类型 链接性为外部
```
内部链接性（静态全局变量）：
```cpp
static int one_file=1000;//静态全局变量 静态存储类型 链接性为内部
```
无链接性（静态局部变量）：
```cpp
void func()
{
	static int a;//静态局部变量 静态存储类型 无链接性
}
```
全局变量（外部变量）与静态全局变量的区别：
案例->3
#### 全局变量

单定义规则：
ODR(only definition rule)指出，**变量只能有一次定义**

变量声明有两种：一种是定义声明（定义），给变量分配存储空间，另一种为引用声明（声明），**不给变量分配存储空间**

引用声明使用`extern`关键字，并且**不进行初始化**，否则，声明为定义。
```cpp
int a;//定义
extern int a; //声明 不会分配存储空间
extern int a=10;//定义
```

要在多个文件中使用外部变量，只需要在一个文件中包含该变量的定义，在使用变量的其他所有文件中，都必须使用extern声明

但是注意，ODR规则并非意味着不能有多个变量的名称相同，比如不同作用域中的自动变量，以及内部变量隐藏外部变量的例子
#### 静态全局变量
与全局变量区别以及全局变量的用法：
案例->3

#### 静态局部变量
特点：**一次初始化+保留值**

案例->4.cpp

静态变量的初始化：
分为静态初始化和动态初始化，静态初始化又分为零初始化和常量表达式初始化

动态初始化时编译后初始化，静态初始化是编译前初始化

```cpp
int func();
int x;//零初始化
int y=5;
int z=sizeof(long)*2;//y和z都是常量表达式初始化
int a=func()*2;//动态初始化 因为要执行完func()函数
```

#### const对存储类型的影响
在默认情况下全局变量的链接性为外部，但是const全局变量的连接性是内部的
```cpp
const int a=10;//等价于static const int a=10;
```

**可以将常量定义在头文件中，但是普通的全局变量是不能的**

因为常量是内部链接性的
```
//config.h 头文件
const int a=10;
//a.cpp
#include"config.h"
//b.cpp
#include"config.h"
```
include在预处理器处理的时候是复制过来，所以a.cpp和b.cpp中都会有const int a=10;的定义，但是由于const变量是内部链接性，所以没有问题。

但如果是普通全局变量的话，单独编译a.cpp和b.cpp是没有问题的，但是将a和b链接的时候就会报错，重复定义了

问题：不是有#ifndef预处理吗？
答案：#ifndef 这套适用于一个cpp文件中重复包含某一个头文件的
```cpp
//a.cpp
#include"b.h"
#include"c.h"
//b.h
#include"c.h"
```
b.h中已经包含了c.h，如果没有#ifndef 这套机制的话，c.h的内容会被复制过来两次，导致错误

但是上面的错误在于链接的时候发生错误，因为全局变量是外部连接性，所以违反了ODR原则

案例->5

也可以使用`extern`使得它有外部链接性，那就和普通全局变量差不多了
```cpp
//config.h
extern const int a;//声明
//config.cpp
const int a=10;
```
其他文件使用时也要注意加上extern来声明使用

### 函数和链接性
和变量一样，函数也有链接性。由于函数中不允许创建一个另一个函数，所以所有的函数自动为静态类型，也就是在整个程序执行期间一直存在

**在默认情况下，函数的链接性为外部，即可以在文件间共享**

**可以使用static关键字将函数的链接性设置为内部，但是注意必须同时在原型和定义中使用该关键字**，这样函数就只能在一个文件中使用了，**不能被其他.cpp文件访问**，那么其他.cpp文件就可以定义同名的函数

非内联函数同样需要遵守ODR规则，也就是对于链接性为外部的函数，在多文件程序中，只能有一个文件（该文件可能是库文件）包含该函数的定义，但是使用该函数的每一个文件都应该包含其函数原型

**内联函数不用遵循ODR规则**，所以是可以将内联函数的定义放在头文件。这样，每一个使用该内联函数的文件都会包含内联函数的定义，但是要求**同一个函数的所有内联函数定义都必须相同**

c++如何寻找函数？
首先通过#include包含头文件，头文件中有函数原型，如果这个函数原型指出这个函数的链接性是内部的，那么编译器只会在该文件中查找函数定义，不然，编译器（包括链接程序）会在所有的程序文件中查找。

如果找到了两个定义，编译器会发送错误消息。**如果在程序文件中没有找到，编译器将在库中搜索**

**也就是说如果定义了一个与库函数同名的函数，编译器将采用程序员自己定义的版本，而不是库函数**


### 动态分配
动态内存由new和delete控制，而不是由作用域和链接性规则控制。（分配的内存存放在堆中）

因此，可以在一个函数中分配动态内存，而在另一个函数中释放内存

虽然说动态内存和之前的自动或者静态类型不一样，但是**管理动态内存的指针还是适用自动或者静态类型的规则**

```cpp
float *p=new float [20];
```
由new运算符分配的20个flaot变量的内存将一直保留在内存当中，直到使用delete运算符将其释放，但是当这个语句块（作用域）结束的时候，p指针将会被销毁，那如果我们其他的函数或者语句块能使用这块内存，那么应该传递这个内存的地址。

案例->7.cpp

#### new运算符的初始化
```cpp
int *p1=new int;//值未定义
int *p2=new int();//默认初始化 值为0 如果是类的话调用默认构造函数
int *p3=new int(10);//直接初始化 如果是类的话可以传参数调用重载构造函数
int *p4=new int[5];//未初始化
int *p5=new int[5]();//默认初始化 这里值全为0
int *p6=new int[5]{1,2,3};//12300
```

#### 定位new运算符(了解)
一般来说，new会在堆找一块满足需要的内存进行存储，但是其实new运算符还有一种变体，被称为定位new运算符，它允许在指定要使用的位置进行存储.

### 名称空间
随着项目的增大，各种名称也会越来越大，名称冲突的可能性就会越来越大。以及不同厂商之间可能都定义了名字相同的内容，但是互不兼容。因而需要有名称空间，来**更好地控制名称的作用域**

#### 几个术语

声明区域：顾名思义就是变量被声明的区域。比如在函数外面声明的全局变量的声明区域就是其声明的文件；对于函数中声明的变量就是其声明的代码块

潜在作用域：就是从声明点开始到声明区域的结尾。比如在一个函数中声明的的一个变量，那么就是从它声明开始到函数结束为其潜在作用域。可见，潜在作用域一般比声明区域小。但是注意，**变量并非在潜在作用域中就是可见的**


作用域：变量实际可见的范围

### 使用名称空间

#### 通过namespace关键字创建名称空间
```cpp
namespace Math{
	int a=10;
	int add(int a,int b){return a+b;}
}
```
名称空间可以是全局的，也可以位于另一个名称空间中（嵌套名称空间），**但是不能定义在代码块中**，也就是不能定义在函数内部、类定义内部

#### 使用::域解析符来使用名称空间中的定义
```cpp
namespace Math{
	int a=10;
	int add(int a,int b){return a+b;}
}
std::cout<<Math::a<<std::endl;
```
案例->8.cpp

由名称空间可以定义的位置，得出名称空间中的名称**链接性为外部**（常量除外、特殊指定除外）**其实就和在函数外部文件中定义是一样的效果（从链接性的角度）**

案例->9

除了用户自定义的名称空间外，还存在另外一种名称空间——全局名称空间，全局变量就定义在全局名称空间中。

**任何的名称空间中的名称都不会和其他名称空间中的名称冲突**

**名称空间是开放的**，也就是说在同一个文件或者不同文件中可以多次拓展名称空间，会自动进行合并

```cpp
//a.cpp
namespace Config
{
	int a=10;
}
namespace Config
{
	int add(int a,int b){return a+b;}
}
//b.cpp
namespace Config
{
	int b=20;
}
```
编译器会自动合并，就像是在一个地方写的一样

c++的标准名称空间std就是一个典型的例子，c++的标准库使用的都是std的名称空间（但是注意std名称空间不允许用户拓展），但是是在许多个文件中分开编写的

#### using声明和using编译指令
除了全局名称空间中的变量和函数，其他名称空间中的变量和函数或者是类，在使用的时候都需要加上`::`域解析符，稍显麻烦。

有两种方式可以减少这种麻烦，一种是using声明可以使得特定的标识符可用，另一种是using编译指令使得整个名称空间可用

using声明就是将特定使用的名称添加到它所属的声明区域

```cpp
namespace Config
{
	int a=10;
}
int a;
int main()
{
	using Config::a;
	//int a;//这是错误的
	cin>>a;
	cin>>::a;
}
```
using声明是写在局部声明区域中的，所以就跟**在main函数中已经定义好了一个局部变量是一样的**，所以再定义一个int a;是非法的。

同时在全局名称变量中也定义了一个a，这个和Config中a的关系就跟全局变量和局部变量关系是完全一样的，在main中直接使用a，那么Config中的a会隐藏全局变量a，要使用全局变量a，要写成`::a`

案例->10.cpp

还可以将using声明写在全局声明区域，这样名称空间中的这个名称将会全局可用，就跟定义一个全局变量是一样的

using编译指令会使得这个名称空间中的所有名称都可用。
然后就不需要用`::`就可以使用了
```cpp
using namespace xxx;
```
最常见的就是`using namespace std;`

注意using编译指令也可以用于局部声明区域

注意不管是使用using编译指令还是using声明，都增加了名称冲突的可能性，如果两个名称空间有相同的命名可能出现问题
```cpp
a::val=3;
b::val=4;//没有问题 因为使用了::

using a::val;
using b::val;
val=3;//出现问题 导致二义性
```

using声明和using编译指令的一个区别

using声明其实就是像一个声明，因而是不允许重复用相同名字的
```cpp
namespace Config
{
	int a=20;
}
int a=10;
//using Config::a;//错误的 因为a已经有定义了
```

而using编译指令只是让这个名称空间中的所有名称变得可见，并不是直接声明，只是在找不到名称的时候可以去这个名称空间中找找
```cpp
namespace Config
{
	int a=20;
}
using namespace Config;
int a=20;//是可以的
cout<<Config::a<<endl;//也可以显示访问这个名称空间中的变量
```
案例->11.cpp

#### 匿名名称空间
匿名名称空间最大的特性是它的链接性**是内部的**，也就是只能在当前文件中使用，隐藏细节，同时可以防止全局命名被污染
```cpp
namespace
{
	int a=10;
	int add(int a,int b){return a+b;}
}
int b=20;
int sub(int a,int b){return a-b;}
```
其中a和add的链接性都是内部，而b和sub的链接性都是外部的。

所以匿名名称空间可以用来替代static来实现内部链接性

