### 变量命名规则
* 只能使用字母字符、数字和下划线（_）。
* 名称的第一个字符不能是数字。
* 区分大写字符与小写字符。（大小写敏感）
* 不能将C++关键字用作名称。
*  **以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。**(工程上要注意)（注意这个是有效的，但是会导致行为的不确定性）
![](https://pic1.imgdb.cn/item/6878f88a58cb8da5c8bee75f.png)
但如果在 **函数内部**、**类的成员函数** 或 **局部作用域** 中使用类似 `_foo`这样的名字，标准并没有强制禁止（虽说为避免歧义，也建议谨慎）。

### 整数类型
#### 关于int
int(32位) 范围：`-2^31 ~ 2^31-1`
ex1：为什么负数范围总比正数范围多一
	原因在于补码定义
![](https://pic1.imgdb.cn/item/6878fc7e58cb8da5c8bee8c0.png)
ex2：
	数量级大概是2x10^9
	（用于判断是用int还是long long)

#### 关于size_t（了解）
一种无符号整型，用于表示内存中对象大小和容器的索引、元素个数等
**宽度**：与机器字长相关：
- 32 位系统：32 位无符号 → 最大值 ≈ 4 294 967 295
- 64 位系统：64 位无符号 → 最大值 ≈ 1.8×10¹⁹
特点：永远大于等于0
**用途**：
- `sizeof` 返回值类型
- STL 容器的 `.size()`、`.length()`、`.capacity()` 等
- 数组和指针算术的索引类型
#### sizeof运算符
`sizeof` 是 C++ 中的一个运算符(**不是函数**），用于获取类型或对象在内存中所占字节数。
```cpp
sizeof(type)        // 对类型取大小，必须加括号
sizeof expr         // 对表达式或变量取大小，括号可省略（但常加以示区分）
```
常见用法：
计算数组长度
```cpp
int a[50];
size_t len=sizeof(a)/sizeof(arr[0]);
```
注意：
```cpp
void func(int *p) {
  // 虽然 p 指向一个数组，但在函数内部它退化为指针
  size_t sz = sizeof(p);        // 8（或4），而非数组大小
}
```
接收一个“数组”的函数参数时，编译器会把它当成普通指针 `int* arr` 处理（也就是退化成指针）
那么再使用上面那种计算数组长度的方式就是错误的！
案例->1.cpp
![](https://pic1.imgdb.cn/item/68790e6f58cb8da5c8bef043.png)
编译器会警告，这里的sizeof arr是返回的`int*`的大小而不是数组的大小、

解决办法->1.传入大小 2.使用vector

ex：对表达式形式的 `sizeof` 并不会真正求值，只是“看”类型
案例->2.cpp
### 关于列表初始化(了解)
C++11 引入了“列表初始化”语法，用大括号 `{}` 统一各种初始化方式，也称为**统一初始化**
第一个优势：统一
```cpp
//内置类型
int    i1{42};       // 直接列表，i1==42
double d2 = {2.5};   // 拷贝列表，d2==2.5
//聚合类型
struct P { int x, y; };
P p1{1,2};               // x=1, y=2
int arr[3]{10,20,30};    // 等同于 {10,20,30}
//stl容器
std::vector<int> v{1,2,3,4};
std::map<int,std::string> m{{1,"one"}, {2,"two"}};
```
第二个优势:安全，对窄化转换会直接报错
什么是窄化转换？
比如以下情况：
- **浮点 → 整数**  
- **高精度浮点 → 低精度浮点**  
- **宽整数 → 窄整数**
![](https://pic1.imgdb.cn/item/687907f758cb8da5c8beece0.png)
简单案例->3.cpp

#### 整型溢出
用比赛计分板去理解

#### 整数字面值（常量）

**进制表示：**

| 书写形式     | 说明             | 示例及值               |
| -------- | -------------- | ------------------ |
| **十进制**  | 不以 `0` 开头      | `42` → 42          |
| **八进制**  | 以 `0` 开头       | `042` → 34         |
| **十六进制** | 以 `0x`/`0X` 开头 | `0x2A`/`0X2a` → 42 |
后缀表示：

|后缀|含义|常见结果类型|
|---|---|---|
|无后缀|根据数值大小和字面值基数推断：`int` → `long` → `long long`|`int`、`long`、`long long`|
|`u` / `U`|**无符号**十／八／十六／二进制整数|`unsigned int` → `unsigned long` → `unsigned long long`|
|`l` / `L`|**长整型**|`long` (或 `unsigned long` 若带 `uL`)|
|`ll` / `LL`|**长长整型**|`long long` (或 `unsigned long long`)|
**默认类型**：在不带后缀的情况下，**十进制**整数字面值会首先被当作 `int` 处理——只要它的值能被 `int` 表示 （常在计算表达式中考察类型的自动转换）

#### 关于char
关键在于理解，也就是 `'0'!=0` 的问题
`char` 在底层就是一种**整数类型**，它存储的是一个“字符代码”（code unit），而不是高级的“字符”对象

在表达式中的运算也是直接的整数运算
一些常用的技巧案例->4.cpp

**字符用单引号，字符串用双引号，不可混用！**
```cpp
'x'//是一个字符
"x"//代表'x''\0'组成的字符数组
```

#### 转义字符
特别注意一下数值转义：

	可以基于字符的八进制和十六进制编码来使用转义序列。例如，Ctr+Z的ASCII码为26，对应的八进制编码为032，十六进制编码为 0x1a。可以用下面的转义序列来表示该字符：\032或\x1a。将这些编码用单引号括起，可以得到相应的字符常量，如'\032'，也可以将它们放在字符串中，如"hi\x1a there"。

##### 八进制转义：`\ooo`

- 语法：反斜杠后紧跟 1–3 位 0–7 的八进制数字
- 含义：把这组八进制数当作一个字节（0–255）的数值来插入
```cpp
'\101'   // 八进制 101 = 十进制 65，对应 ASCII 'A'
"\012"   // 八进制 012 = 十进制 10，对应换行符 '\n'
'\0'     // 八进制 0 = 十进制 0，空字符
```
注意：最多三位。如果写 `'\1234'`，编译器会先把 `\123` （八进制 83，即字符 'S'）解析掉，然后再把后面的 `4` 当作普通字符。

##### 十六进制转义：`\xhh…`

- 语法：反斜杠 + `x` + 一或多位十六进制数字（0–9, A–F/a–f）
- 含义：把这组十六进制数当作字符代码插入
```cpp
'\x41'    // 0x41 = 十进制 65 = 'A'
"\x0A"    // 0x0A = 十进制 10 = 换行符 '\n'
"\x7F"`   // 0x7F = DEL 控制字符
```
注意：与八进制不同，`\x` 后面所有符合十六进制的字符都会被算进数字，直到遇到非十六进制字符才停止。因此 `"\x4142Z"` 会被当作单个码点 0x4142（十进制 16706）和后面的 `'Z'`；若想分开写，最好在数字后加个结束符号，比如 `"\x41" "42Z"` 或 `"\x41""42Z"`。

##### Unicode 转义（了解）

- **`\uXXXX`**：四位十六进制，表示 Unicode 码点 U+0000…U+FFFF，类型取决于上下文是 char16_t 还是 char32_t
- **`\UXXXXXXXX`**：八位十六进制，表示码点 U+00000000…U+10FFFF，通常用于 char32_t
```cpp
char16_t c16 = u'\u4E2D';     // “中”的 UTF‑16 编码单元
char32_t c32 = U'\U0001F600'; // “😀” 的 UTF‑32 编码单元
```

#### const限定符
定义常量的，这里只强调一点
**初始化的时候必须赋值(因为后续不能再改变)**
```cpp
const int a = 42;   // 正确:立刻初始化
const int b;        //  错误：const 变量必须初始化
```
-->不推荐使用#define
	`#define` 是 C/C++ 预处理器的指令，用于在编译之前做简单的文本替换。
	核心在于**完全替换，不会做任何检查**
	可能导致类型不匹配，优先级问题等等，并且还不方便检查


### 浮点数
E表示法,适合于非常大和非常小的数(数字中不能有空格，比如7.2 E6是非法的)

**注意浮点常量默认是double类型的(加f或者F后缀成为float类型,加l或者L成为long double类型)**

注意一个大数和一个小数相加，可能会丢失小数

### 算术运算符
`/`：整数与整数相除还是整数（会直接舍弃掉小数部分）
`%`：
* 只支持整数
* 向0截断，也就是`a % b` 的符号 **等于** `a` 的符号
* 优先级和`*`、`/`相同
```cpp
10  %  3   // =  1   (10 = 3*3 + 1)
10  % -3   // =  1   (10 = -3*(-3) + 1)
-10 %  3   // = -1   (-10 = 3*(-3) + -1)
-10 % -3   // = -1   (-10 = -3*3 + -1)
```
递增递减运算符：前置和后置
多次使用可能导致语义模糊，在不同系统下结果可能不同，所以不能滥用

### 逗号运算符
逗号运算符是一种二元运算符，用来**顺序执行多个表达式**，并返回**最后一个表达式的结果**。
```cpp
表达式1, 表达式2, 表达式3;
```
但是逗号并不总是逗号运算符
比如
```cpp
int i,j;
```
在所有运算符中，逗号运算符的优先级是最低的
```cpp
a=20,30;//a=20
a=(20,30);//a=30
```

### 赋值运算符
`==`与`=`区分
### 类型转换
常见场景：
1. 赋值
2. 表达式求值
3. 函数传参（后续再了解）
#### 赋值时的类型转换
右边的值会被转换为接收变量的类型
将一个值赋给值取值范围更大的类型通常不会导致什么问题
有些会导致一些潜在问题：
* 较大的浮点类型->较小的浮点类型    精度丢失
* 浮点类型-> 整型   小数部分丢失，原来的值可能超过目标类型的值，这种情况下，结果不确定
* 较大整型转换为较小整型   可能超过取值范围，通常只复制右边的字节
但是之前提到的`{}`统一初始化不允许窄化，这就体现出了安全的一个优势

#### 表达式中的转换
当表达式中包含两种不同的算术运算符的时候，C++将执行自动转换

在计算表达式的时候，bool、char、unsigned char、signed char和short值转换为int，这些转换叫做整型提升(还有些其他的)

**一个整数和double,另一个操作数将被转换为double**

![](https://pic1.imgdb.cn/item/687a3a8858cb8da5c8c3a2d5.png)

#### 强制类型转换
```cpp
int a;
(long)a;
long (a);//两种格式
```
**注意！强制类型转换并不会改变变量本身，而是创建一个新的、指定类型的值**
案例->5.cpp

### C++11中的auto声明（简）
用于自动推断类型，在后续复杂的类型中（比如stl中的类型）将比较好用，但是对于简单类型不推荐使用。

