### 函数的基本知识
函数可以分为有返回值和没有返回值的函数，没有返回值的函数又叫做void函数

函数定义：
```cpp
返回值类型 函数名(参数列表)
{
	函数体
	return 语句;//optional
}
```
其中对于void函数，return语句是可选的，但是对于有返回值的函数**必须有return语句**

有返回值的函数将生成一个值，并将他返回给调用函数


**注意如果是有返回值的函数return 语句返回的值要么是函数定义的返回值类型，或者可以进行自动转换，也就是说是以函数定义的返回值类型为准**

函数原型：
为什么需要函数原型？可以让编译器提前知道函数信息（给了函数定义的灵活性）同时编译器可以在调用函数的位置进行类型检查

```cpp
返回值类型 函数名(参数列表);
```
与函数定义的区别：
1.没有函数体，以分号结尾
2.**函数原型不要求提供变量名，有类型列表就足够了，变量名甚至可以不与函数定义相同，因为变量名相当于占位符**

案例->1.cpp

函数调用的时候如果传进去的的类型和不一致，如果能自动转换将自动转换（部分编译器会发出警告），如果不能自动转换，则会报错

值传递：
先创建一个副本，然后将副本传递给函数
对于大型数据来说（比如vector）效率太慢，并且浪费空间
好处是对原本的变量进行修改

案例->2.cpp

地址传递：
把变量的“地址”传给函数，让函数可以**直接修改调用者的变量内容**。

不会创建副本，效率高，但是可能会修改原来的变量

分为传指针和传引用

传指针->3.cpp

什么是引用？
引用是某个已存在变量的**别名**，它和这个变量绑定在一起，不能更改为引用其他变量

| 特性         | 说明                     |
| ---------- | ---------------------- |
| **必须初始化**  | 引用在定义时必须绑定某个已有变量       |
| **不能重新绑定** | 一旦引用某个变量后，就不能再引用其他变量   |
| 本质上是别名     | 引用不是新开辟的空间，它和原变量共用一个地址 |
```cpp
int &a;//错误
```
案例->4.cpp
### 函数与数组
将数组作为参数传递给函数
```cpp
int func(int arr[]);
```
**c++中，数组 不能整个传递给函数，传递的是数组首元素的地址，也就是arr从数组类型退化为指针类型**

所以我们还能这样写
```cpp
int func(int *arr);
```
`int *arr`和i`int arr [ ]`的含义是相同的。它们都意味着arr是一个int指针，并且是指向第一个元素的指针

同时这也解释了为什么在main函数和调用函数中使用`sizeof(arr)`会得到不同的结果

案例->5.cpp

并且要注意因为是地址传递，所以是**可能会修改原数组的**

### 在函数传参中使用const限定符
使用const限定符可以防止原变量被修改，同时又可以避免拷贝，提高效率，**也就是让变量变成只读的**

很明显，在值传递的场景中使用const限定符没有任何价值（因为值传递本身就不会修改）

如何使用？和用const来定义变量是完全一样的（其实函数参数列表就可以看作是定义变量的地方）
```cpp
void func(const int &a)
{
	a=10;//错误 修改会报错
}
void func1(const int *p)
{
	*p=10;
}
void func2(int const *p)
{
	int b;p=&b;
}
```

### 数组指针和指针数组

指针数组是一个数组，每一个元素是指针
```cpp
int* arr[5];
```
数组指针是一个指针，指向一个数组
```cpp
int arr[5];
int (*p)[5]=&arr;
//区别
int *p=&arr;
```

### 函数与二维数组

同样的函数也无法传递多维数组，数组名也是退化为指针，**因而不能自动推导维度信息，必须提供维度信息**

```cpp
int func(int arr[][4]);//必须手动指定维度信息
int func1(int (*arr)[4]);
```
二维数组名退化为**指向一维数组**的指针

```cpp
int arr[5][6];
arr[3][4];
*(*(arr+3)+4));
```

### 函数与字符串与结构体
c风格字符串，直接按数组操作

string类型与结构体，直接按基本类型操作

### 递归函数的简单介绍
**递归函数** 是指 **在函数内部调用自身** 的函数

两个核心：**递归出口（用于终止递归的条件）**和递归调用

#### 斐波拉契数列

```cpp
F(n) = F(n-1) + F(n-2)   （n ≥ 2）
```
首先确定递归出口，然后根据转移方程写出代码
```cpp
int f(int x)
{
	if(x<=1)return x;
	return f(x-1)+f(x-2);
}
```
实例求`f(5)`

可以发现，存在大量的冗余计算

使用备忘录来实现
```cpp
int f(int x,vector<int>&memo)
{
	if(x<=1)return x;//base case
	if(memo[x]!=-1)return memo[x];
	memo[x]=f(x-1,memo)+f(x-2,memo);
	return memo[x];
}
```

进一步可以使用迭代来实现
```cpp
vector<int>f(n+1);
f[0]=0,f[1]=1;
for(int i=2;i<=n;i++)f[i]=f[i-1]+f[i-2];
```

进一步我们可以发现，当前状态只和前一个和前两个转态有关，所以我们可以进一步压缩空间
```cpp
int a=0,b=1,c;
for(int i=2;i<=n;i++)
{
	c=a+b;
	a=b;
	b=c;
}
```

#### 汉诺塔问题

问题描述：
```
有三根柱子：A（起始柱）、B（辅助柱）、C（目标柱）。  
在柱子 A 上叠着从小到大 `n` 个圆盘（小的在上，大的在下）。  
目标是：把所有圆盘从柱子 A 移动到柱子 C，每次只能移动一个圆盘，并且：

1. 一次只能移动一个盘子；
    
2. 大盘子不能放在小盘子上面。
```
base case是什么？只有一个圆盘

子结构
- **先把前 `n-1` 个盘子** 从 A 移到 B；
    
- **把第 `n` 个盘子（最大盘）** 从 A 移到 C；
    
- **再把 `n-1` 个盘子** 从 B 移到 C。

```cpp
#include <iostream>
using namespace std;

void hanoi(int n, char from, char aux, char to) {
    if (n == 1) {
        cout << "Move disk 1 from " << from << " to " << to << endl;
        return;
    }
    hanoi(n - 1, from, to, aux);             // 第一步
    cout << "Move disk " << n << " from " << from << " to " << to << endl; // 第二步
    hanoi(n - 1, aux, from, to);             // 第三步
}
```
案例->6.cpp

### 指针函数和函数指针(了解)

跟变量一样，函数也有地址。函数的地址是存储其机器语言代码的内存的起始地址。

函数地址有什么用呢？比如我们可以编译一个函数将宁一个函数的地址作为参数，这样函数在不同情况下运行不同的函数。比如sort函数的第三个参数传入的就是一个函数

案例->7.cpp

#### 指针函数
指针函数 顾名思义就是返回类型为指针的函数

**但是要注意不要返回局部变量的地址**

案例->8.cpp

#### 函数指针
我觉得就和数组指针一样的理解方法就好

函数名在表达式中转化为函数指针，值就是函数的起始地址

定义一个函数指针
`返回值类型(*指针名)(参数列表)`
```cpp
int func(int,double);
int (*p)(int,double)=func;
```
案例->9.cpp

### 使用typedef创建类型别名
```cpp
typedef 原类型 新名字;
```
比如
```cpp
typedef long long ll;
ll a;
```
