### 变量赋值
在 Bash 中，为变量赋值的基本语法如下：

`变量名=值`

⚠️注意事项：

- 赋值时**等号两边不能有空格**。
    
- 变量名通常由字母、数字和下划线组成，**不能以数字开头**。
    
- 赋的值可以是字符串、数字等，但默认都被当作字符串处理。

**Bash 中的字符串通过 `'` 和 `"` 分隔符来定义，但是它们的含义并不相同。以 `'` 定义的字符串为原义字符串，其中的变量不会被转义，而 `"` 定义的字符串会将变量值进行替换。**
`name=alice;echo '$name'输出$name`
`name=alice;echo "$name"`输出alice
用`$变量名`来获取变量值

### 串起多个命令
1. 用`;`进行分隔,不管前一个命令是否执行成功都继续执行下一个
2. 用`&&`连接，表示只有前一个命令执行成功了才执行下一个（短路效应）
3. 用`||`连接，表示只有前一个命令执行失败了才执行下一个
4. * 小括号 `()`：在**子 Shell** 中执行，不会影响当前 Shell 的变量。    
- 大括号 `{}`：在**当前 Shell** 中执行，注意：大括号和命令之间要有空格，结尾要加分号 `;`
分行写命令用`\`续行表示这一行还没有写完，注意命令间的连接仍然不能少，也就是换行不作为命令间的分隔

### 特殊变量来表示参数
与其他脚本语言不同的是，bash 使用了很多特殊的变量来表示参数、错误代码和相关变量。下面列举了其中一些变量，更完整的列表可以参考 [这里](https://www.tldp.org/LDP/abs/html/special-chars.html)。

- `$0` - 脚本名
- `$1` 到 `$9` - 脚本的参数。 `$1` 是第一个参数，依此类推。
- `$@` - 所有参数
- `$#` - 参数个数
- `$?` - 前一个命令的返回值
- `$$` - 当前脚本的进程识别码
- `!!` - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 `sudo !!` 再尝试一次。
- `$_` - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 `Esc` 之后键入 . 来获取这个值。

命令通常使用 `STDOUT` 来返回输出值，使用 `STDERR` 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值 0 表示正常执行，其他所有非 0 的返回值都表示有错误发生。

### grep
`grep` 主要用于从文件或标准输入中查找匹配某个模式的行，并输出这些行。

### 基本语法：

```bash
grep [选项] pattern [文件...]
```

- **pattern**：要匹配的模式，通常是一个正则表达式。
    
- **文件**：要搜索的文件，如果不指定文件，`grep` 会从标准输入（即键盘）读取内容。
    
### 常用选项：

- `-i`：忽略大小写进行匹配。
    
- `-v`：反转匹配，输出不匹配模式的行。
    
- `-r` 或 `-R`：递归地搜索目录中的文件。
    
- `-l`：只输出匹配到的文件名，不显示匹配的内容。
    
- `-n`：显示匹配行的行号。
    
- `-c`：只输出匹配的行数。
    
- `-H`：在输出中显示文件名（当搜索多个文件时）。
    
- `-o`：只输出匹配的部分，而不是整行。
    
### 例子：

1. **查找文件中包含特定字符串的行**：
    
    ```bash
    grep "hello" file.txt
    ```
    
    这会查找 `file.txt` 文件中所有包含 "hello" 的行。
    
2. **忽略大小写**：
    
    ```bash
    grep -i "hello" file.txt
    ```
    
    这会查找 `file.txt` 文件中所有包含 "hello"（忽略大小写）的行。
    
3. **查找目录中的所有文件**：
    
    ```bash
    grep -r "hello" /path/to/directory/
    ```
    
    递归查找指定目录下所有文件中包含 "hello" 的行。
    
4. **显示匹配的行号**：
    
    ```bash
    grep -n "hello" file.txt
    ```
    
    这会输出 `file.txt` 中所有包含 "hello" 的行及其行号。
    
5. **反转匹配**：
    
    ```bash
    grep -v "hello" file.txt
    ```
    
    这会输出 `file.txt` 中所有**不包含** "hello" 的行。
    
6. **只显示匹配的部分**：
    
    ```bash
    echo "hello world" | grep -o "hello"
    ```
    
    这会输出 "hello"，而不是整行。
    


### 递归查找
**递归查找**（Recursive Search）指的是在一个目录及其所有子目录中，自动地一层层地搜索目标文件或数据。换句话说，递归查找不仅会查找当前目录下的文件，还会进入每个子目录，再在这些子目录中继续查找，直到所有的目录都被搜索完。

在文件系统中，目录可以包含子目录，而子目录又可以包含更多的子目录。递归查找会自动深入这些层级，而不需要手动指定每个子目录。

### 举个例子：

假设你有以下的目录结构：

```
/home/user/
├── file1.txt
├── file2.txt
├── subdir1/
│   ├── file3.txt
│   └── subdir2/
│       └── file4.txt
└── subdir3/
    └── file5.txt
```

如果你使用递归查找来查找 `file` 这个字符串：

```bash
grep -r "file" /home/user/
```

`grep` 会：

1. 查找 `/home/user/` 目录中的文件（即 `file1.txt` 和 `file2.txt`）。
    
2. 然后查找 `/home/user/subdir1/` 目录中的文件（即 `file3.txt`）。
    
3. 然后再查找 `/home/user/subdir1/subdir2/` 目录中的文件（即 `file4.txt`）。
    
4. 最后查找 `/home/user/subdir3/` 目录中的文件（即 `file5.txt`）。
    

**结果是，它会遍历整个文件系统结构，找到所有匹配的内容。**

### 为什么要使用递归查找？

- **方便**：你不需要列出每个子目录的路径，命令会自动深入所有目录层级。
    
- **高效**：特别适用于层级较深的文件系统，避免了手动查找每个子目录的麻烦。
    

### 使用递归查找的常见命令：

- **`grep -r`**：递归查找匹配的文本行。
    
- **`find`**：递归查找符合条件的文件。 例如，查找所有 `.txt` 文件：
    
    ```bash
    find /path/to/dir -name "*.txt"
    ```
    
- **`ls -R`**：列出目录及其子目录中的所有文件。
    

### 总结：

递归查找是指从一个目录开始，自动深入到所有子目录中，查找符合条件的文件或数据，避免了手动指定每个目录路径的麻烦，非常适合层次复杂的文件结构。
也就是说如果不用递归查找的话，就只会搜寻给予的目录，而如果启用递归查找的话，给予的目录以及其子目录都会被查找