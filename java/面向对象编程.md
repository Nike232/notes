### 类和对象
...
java中一个源文件可以定义多个类，**但是只能定义一个public类，并且类名必须和文件名相同**

#### 参数绑定
基本类型，没什么特别的
```java
// 基本类型参数绑定
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        int n = 15; // n的值为15
        p.setAge(n); // 传入n的值
        System.out.println(p.getAge()); // 15
        n = 20; // n的值改为20
        System.out.println(p.getAge()); // 15还是20?
    }
}

class Person {
    private int age;

    public int getAge() {
        return this.age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```
引用类型，特别注意!
```java
// 引用类型参数绑定
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        String[] fullname = new String[] { "Homer", "Simpson" };
        p.setName(fullname); // 传入fullname数组
        System.out.println(p.getName()); // "Homer Simpson"
        fullname[0] = "Bart"; // fullname数组的第一个元素修改为"Bart"
        System.out.println(p.getName()); // "Homer Simpson"还是"Bart Simpson"?
    }
}

class Person {
    private String[] name;

    public String getName() {
        return this.name[0] + " " + this.name[1];
    }

    public void setName(String[] name) {
        this.name = name;
    }
}
```
因为引用数据类型类似于指针，所以对象p中的属性name指向的内存和外部fullname指定的内存是相同的，所以在外部修改用fullname修改了内存的某些值，对应的对象的属性也相应进行了改变

另一个例子：
```java
// 引用类型参数绑定
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        String bob = "Bob";
        p.setName(bob); // 传入bob变量
        System.out.println(p.getName()); // "Bob"
        bob = "Alice"; // bob改名为Alice
        System.out.println(p.getName()); // "Bob"还是"Alice"?
    }
}

class Person {
    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```
这个两次都输出Bob，虽然String是引用数据类型，但是bob="Alice"是bob指向了另一块内存，所以原本的内存并没有改变

#### 构造方法（构造函数）
特点：
1.没有返回值
2.与类名相同
3.参数没有限制
```java
class Person{
	private String name;
	private int age;
	public Person(String name,int age)
	{
		this.name=name;
		this.age=age;
	}
}
```
调用构造函数（方法）,必须使用new操作符

如果自己没有写，会存在一个默认构造函数，它没有参数，也没有执行语句

**如果我们自定义了一个构造方法，编译器就不再自动创建默认构造方法**

**如果类的field没有被初始化，那么都会采用默认值，比如引用类型是null,int类型是0，布尔类型是false**

也可以在定义字段的时候进行初始化，那么如果既在字段进行了初始化，又在构造方法中进行了初始化，那么该用谁呢？

执行顺序是先初始化字段，然后执行构造方法进行初始化，所以最后是由构造方法确定的

**构造函数运行重载，但是参数列表必须不同**，在一个构造方法中可以调用其他构造方法，方便代码复用，this(.....)

比如
```java
public class Person{
	private String name;
	private int age;
	
	public Person(String name,int age)
	{
		this name=name;
		this age=age;
	}
	public Person(String name)
	{
		this(name,18);
	}
	public Person()
	{
		this("Unnamed");
	}
}
```


### 继承
java使用`extends`关键字来实现继承
```java
class Person {
    private String name;
    private int age;

    public String getName() {...}
    public void setName(String name) {...}
    public int getAge() {...}
    public void setAge(int age) {...}
}

class Student extends Person{
	//不要重复定义name和age字段/方法
	//只需要定义新增score字段/方法
	private int score;
	
	public int getScore(){...}
	public void setScore(int score){...}
}
```
**注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！**

我们把Person叫做超类、父类、基类，把Student叫做子类、拓展类

在java中，其实除了Object，都会继承某个类，只不过继承Object通常可以省略，编译器会自动加上extends Object

**Java只允许一个class继承一个类，因此一个类有且仅有一个父类，除了Object没有父类**

#### protected
**子类无法访问父类的private字段或者private方法，例如Student类就无法访问Person类中的name和age字段

这就使得继承的作用被削弱了，但是如果改成public又不满足封装的要求了，所以我们可以使用protected

**被protected修饰的字段可以被子类访问**

#### super
super表示父类，子类引用父类的字段时，可以用`super.fileName`
```java
class Student extends Person {
    public String hello() {
        return "Hello, " + super.name;
    }
}
```
实际上这里使用super.name或者this.name或者name，效果都是一样的

但是有时候必须使用super

比如下面的例子
```java
// super
public class Main {
    public static void main(String[] args) {
        Student s = new Student("Xiao Ming", 12, 89);
    }
}

class Person {
    protected String name;
    protected int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Student extends Person {
    protected int score;

    public Student(String name, int age, int score) {
        this.score = score;
    }
}

```
这里编译器会报错，说是Studeng的构造方法中，无法调用Person的构造方法


这是因为，在java中，任何class的构造方法，**第一行语句必须是调用父类的构造方法**，如果没有明确的调用父类的构造方法，编译器会帮我们自动加一句`super()`，但是Person中没有无参数的构造函数，所以失败了

所以应该改成
```java
class Student extends Person{
	protected int score;
	public Student(String name,int age,int score)
	{
		super(naem,age);
		this.score=score;
	}
}
```
而且说明了**子类不会继承父类的任何构造方法**，子类默认的构造方法是编译器自动生成的，不是继承的





