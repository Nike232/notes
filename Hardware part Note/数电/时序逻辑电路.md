### 一些概念
时序逻辑电路是指具有**记忆**功能的电路，核心部件是**触发器**（能记忆一位二进制数的电路）

数字逻辑电路分为组合逻辑电路和时序逻辑电路
组合逻辑电路的特点是输出随当前输入而变化
时序逻辑电路的输出不仅与该时刻的输入有关，还和电路原状态有关，即与之前的输入有关

> ([[L9-Chap5-触发器.pdf#page=4&selection=24,0,30,2&color=red|L9-Chap5-触发器, p.4]])
> 结构：由**组合电路**和**存储电路**组成

#### 分类
**按照有无同一的时钟脉冲分为同步和异步**
	> ([[L9-Chap5-触发器.pdf#page=8&selection=9,0,24,1&color=note|L9-Chap5-触发器, p.8]])
> 同步：有统一的时钟CP，状态变更与CP同步 
> 异步：无统一CP，状态变更不同步，逐级进行

**按照输出信号特点分**
> ([[L9-Chap5-触发器.pdf#page=8&selection=31,0,48,12&color=note|L9-Chap5-触发器, p.8]])
> 米里型（Mealy）：输出信号不仅与存储状态有关, 还与外部输入有关 
> 莫尔型（Moore）：输出信号仅与存储状态有关
> **注意这里是输出信号是否和外部输入有关，而不是有无外部信号**

### 触发器
见[[触发器]]
### 同步时序逻辑电路的分析
#### 抓住三大方程
1. 驱动方程：**输入端**的逻辑表达式
2. 次态方程：将驱动方程代入到各个触发器的特征方程得到次态方程
3. 输出方程：输出信号的逻辑表达式

其中输出方程一般不容易出错，**尤其需要注意的是驱动方程和次态方程一定不能写错！！！**不然后面就是全错

然后就是列表和画图，**注意检查是否有自启动功能**，这比较容易忘，最后确定电路的逻辑功能

检查电路是否能自启动就是看在状态转移表中没有出现的工作转态（非工作状态）出发能否进入工作状态

**最后画出完整的状态图，把非工作状态加进去**

**如果有外部输入**
那么要分情况,比如分为x=0的时候x=1的时候

### 异步时序逻辑电路的分析
#### 特点：
1. 电路无统一的时钟信号
2. **除了时钟脉冲外没有其他输入信号**由时钟脉冲直接引起电路状态的变化！！！这点和同步时序逻辑电路不一样，要注意
3. 由次态逻辑产生各个触发器的驱动信号以及时钟信号

除了三大方程外，增加一个**时钟方程**

**每一次状态转换必须从输入信号所能触发的第一个触发器开始逐级确定**
逐级分析各个触发器的时钟信号是否出现触发沿，若出现，求出次态，若未出现，则保持原状态
> ([[L10-Chap5-时序逻辑电路分析.pdf#page=38&selection=15,1,20,25&color=red|L10-Chap5-时序逻辑电路分析, p.38]])
> 时间延迟各个触发器的状态转换存在一定的延迟。只有当全部触发器状态转换完毕，电路才进入新的“稳定”状态，即次态

![[L10-Chap5-时序逻辑电路分析.pdf#page=39&rect=425,214,680,402&color=red|L10-Chap5-时序逻辑电路分析, p.39]]
![[L10-Chap5-时序逻辑电路分析.pdf#page=42&rect=5,0,712,484&color=red|L10-Chap5-时序逻辑电路分析, p.42]]

### 同步时序逻辑电路的设计
首先是进行逻辑抽象，要实现某个功能需要几个输入几个输出几个电路转态

然后根据功能画出**状态转移图**然后再列出**状态转移真值表**

序列检测分为重叠型和非重叠型，要注意审题

#### 状态化简
!!!之后要**合并等效状态，消去多余状态，利用状态与状态间的等效关系进行状态化简**
![[L11-Chap5-时序逻辑电路设计.pdf#page=15&rect=10,34,714,361|L11-Chap5-时序逻辑电路设计, p.15]]
![[L11-Chap5-时序逻辑电路设计.pdf#page=16&rect=19,34,707,484|L11-Chap5-时序逻辑电路设计, p.16]]
首先要判断是否是等效对，首先要满足第一个条件，也就是输入相同的时候输出相同。然后满足下列条件之一：
1.  次态相同，顾名思义
2. 次态交错
3. 次态维持
4. 后继状态等效
5. 次态循环>[!PDF|note] [[L11-Chap5-时序逻辑电路设计.pdf#page=20&selection=1,1,48,4&color=note|L11-Chap5-时序逻辑电路设计, p.20]]
> > 次态之间相互循环， 是指状态S1和S2等价的前提条件是状态S3和S4等价， 而S3和S4等价的前提条件又是状态S1和S2 等价， 此时， S1和S2等价， S3和S4也等价。


对于简单的我们就根据上面的原则进行判断，但是对于更加复杂的关系，我们可以采用隐含表法进行状态化简
![[L11-Chap5-时序逻辑电路设计.pdf#page=21&rect=65,83,629,343&color=note|L11-Chap5-时序逻辑电路设计, p.21]]
![[L11-Chap5-时序逻辑电路设计.pdf#page=22&rect=7,23,708,498&color=note|L11-Chap5-时序逻辑电路设计, p.22]]
![[L11-Chap5-时序逻辑电路设计.pdf#page=25&rect=30,237,702,475&color=note|L11-Chap5-时序逻辑电路设计, p.25]]
![[L11-Chap5-时序逻辑电路设计.pdf#page=26&rect=19,3,704,484&color=note|L11-Chap5-时序逻辑电路设计, p.26]]
然后进行状态分配，状态分配就是个最小化状态表中每个状态分配一个二进制代码

首先我们要确认的是，不一定非得是从1到2这样顺序编码，编码是任意的，但应该要起到简化的作用，所以对于不用的编码方案我们要进行选择。

如果电路为Moore型，那么相同输出的状态尽量分配相近的编码
如果电路为Mealy型，对输入相同、输出相同、状态转移相近的状态也可以用相近的编码

主要是使得状态之间的转移只影响少数位，便于触发器逻辑化简

![[L11-Chap5-时序逻辑电路设计.pdf#page=29&rect=23,27,703,302&color=note|L11-Chap5-时序逻辑电路设计, p.29]]
![[L11-Chap5-时序逻辑电路设计.pdf#page=31&rect=28,0,701,478&color=note|L11-Chap5-时序逻辑电路设计, p.31]]

![[L11-Chap5-时序逻辑电路设计.pdf#page=33&rect=40,36,668,472&color=note|L11-Chap5-时序逻辑电路设计, p.33]]
用其他触发器也是一样的思路
但是T触发器有点不同
![[L11-Chap5-时序逻辑电路设计.pdf#page=37&rect=23,43,680,485&color=note|L11-Chap5-时序逻辑电路设计, p.37]]
因为T触发器看的不是0和1而是关注状态是否翻转，如果需要翻转，则T为1，否则为0，所以问题就变成了什么时候输出T为1，那么就找到所有的翻转，为1，保持则为0

最后就是检查自启动功能
> [!PDF|note] [[L11-Chap5-时序逻辑电路设计.pdf#page=40&selection=10,0,24,0&color=note|L11-Chap5-时序逻辑电路设计, p.40]]
> > 讨论两个问题： (1) 电路万一进入无用状态，能否在时钟脉冲作用下进入有效状态，即是否具有自恢复功能和自启动功能。 (2) 电路万一处在无用状态，是否会产生错误信号
> 
> [!PDF|yellow] [[L11-Chap5-时序逻辑电路设计.pdf#page=41&selection=10,15,42,15&color=yellow|L11-Chap5-时序逻辑电路设计, p.41]]
> > 解决电路不能自启动常用以下两种方法： (1) 明确定义非完全描述电路中偏离状态的次态， 使其成为完全描述时序电路。但是， 这种方法由于失去了任意项， 会增加电路的复杂程度。 (2) 变换驱动方程的表达式。用卡诺图化简时， 可以在分析观察的基础上有选择地改变某些驱动方程的圈法。这样做既可以克服死循环， 又不会增加驱动方程的复杂程度。


### 常用时序电路及其应用
> [!PDF|note] [[L11-Chap5-时序逻辑电路设计.pdf#page=52&selection=2,0,26,1&color=note|L11-Chap5-时序逻辑电路设计, p.52]]
> > 同步计数器的特点： 在同步计数器内部，各个触发器都受同一时钟脉冲——输入计数脉冲的控制，因此，它们状态的更新几乎是同时的，故被称为“同步计数器”

#### 用集成计数器实现任意进制计数
若已有N进制计数器，现在要实现M进制计数器
> [!PDF|red] [[L12-Chap5-常用时序逻辑电路.pdf#page=4&selection=26,0,30,7&color=red|L12-Chap5-常用时序逻辑电路, p.4]]
> > M<N：反馈清零法或反馈置数法 M>N：多个芯片级联

> [!PDF|yellow] [[L12-Chap5-常用时序逻辑电路.pdf#page=5&selection=3,0,34,1&color=yellow|L12-Chap5-常用时序逻辑电路, p.5]]
> > 在N进制计数器的顺序计数过程中，若设法使之跳过（N－M）个状态，就可以得到M进制计数器，其方法有清零法（复位法）和置数法（置位法）

#### 反馈清零法（M<N)
分为异步清零和同步清零，但是基本思想都是计数器从s0开始计数，计数满m个之后产生清零信号，使得计数器恢复到初态，然后重复这个过程
##### 异步清零
> ([[L12-Chap5-常用时序逻辑电路.pdf#page=7&selection=42,0,81,1&color=red|L12-Chap5-常用时序逻辑电路, p.7]])
> 步骤： （1）写出状态SM的二进制代码 （2）求归零逻辑：SM中所有1对应的端口求与（高电平有效）或者求与-非（低电平有效） （3）画出电路连线图 

Sm状态只是短暂存在，在该脉冲周期绝大多数时间还是0态，所以Sm不算在主循环里面

**异步清零的问题**，因为触发器复位或者置位的速度可能不同，因而可能还没有恢复到全0，置零信号就已经消失了（置零信号不能保持）所以可能导致误动作

##### 同步清零
> ([[L12-Chap5-常用时序逻辑电路.pdf#page=8&selection=21,0,60,7&color=red|L12-Chap5-常用时序逻辑电路, p.8]])
> 步骤： （1）写出状态SM-1的二进制代码 （2）求归零逻辑：SM-1中所有1对应的端口求与 （高电平有效）或者求与-非（低电平有效） （3）画出电路连线图

Sm-1是有效态，但是必须等到下一个CP脉冲才能复位，但是没有异步清零的误动作问题

> ([[L12-Chap5-常用时序逻辑电路.pdf#page=14&selection=4,0,14,4&color=red|L12-Chap5-常用时序逻辑电路, p.14]])
> 清0法中，计数器每次都是从全0状态S0开始计数

#### 置数法(M<N)
> ([[L12-Chap5-常用时序逻辑电路.pdf#page=14&selection=18,0,42,1&color=red|L12-Chap5-常用时序逻辑电路, p.14]])
> 置数法可以通过预置功能使计数器从某个预置状态 Si开始计数，计满 M 个状态后产生置数信号， 使计数器又进入预置状态 Si，然后再重复上述过程。

> ([[L12-Chap5-常用时序逻辑电路.pdf#page=15&selection=2,0,38,7&color=note|L12-Chap5-常用时序逻辑电路, p.15]])
> 异步置数： 在暂态 Si+M 产生置数信号， 并马上将预置数置于计数器
> 同步置数：在状态 Si+M-1 产生置数信号，要等下一个 CP 到来时，才将预置数置入计数器，故无暂态

基本思路还是和清零法一样，只不过一个是置零，一个是放到输入数据的端口，然后再在预设数据处输入Si的数据罢了，异步置数同样有误动作的风险，因为置数信号不能保存

#### 分解法（M>N）
> ([[L12-Chap5-常用时序逻辑电路.pdf#page=21&selection=20,0,87,1&color=red|L12-Chap5-常用时序逻辑电路, p.21]])
> 若M可分解为 M= M1× M2×… Mn，则用 n片计数器分别组成M1、 M2、 … Mn进制计数器，然后再将它们级联而成级联方法： 
> 并行进位法：所有芯片共用一个时钟信号，低位芯片的进位输出控制相邻高位芯片的使能端（同步方式） 
> 串行进位法：低位芯片的进位输出作为相邻高位芯片的CP （异步方式） 

**注意是乘法不是加法**
#### 拓展法
> ([[L12-Chap5-常用时序逻辑电路.pdf#page=22&selection=19,0,44,1&color=red|L12-Chap5-常用时序逻辑电路, p.22]])
> 先将 n片计数器级联组成最大计数值 N＞ M 的计数器，然后采用整体清0或整体置数的方法实现模 M 计数器。

### 寄存器
分为基本寄存器（数码寄存器）和移位寄存器
输入输出方式：
1. **并行方式**：每一位数据对应一个输入端（输出端），在CP作用下，各位**同时**输入（输出）
2. **串行方式**：只有一个输入端（输出端），CP作用下，各数码**逐位**输入（输出）

> ([[L12-Chap5-常用时序逻辑电路.pdf#page=34&selection=22,0,37,3&color=yellow|L12-Chap5-常用时序逻辑电路, p.34]])
> 移位： 将寄存器所存储的各位数据，在每个移位脉冲的作用下，向左或向右移动一位
> 根据移位的方向，分成：左移、右移和双向移位寄存器







