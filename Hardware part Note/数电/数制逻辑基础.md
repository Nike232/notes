### 数制
十进制转化为R进制：
整数部分除取余数，**逆序**
小数部分乘取整数，**顺序**

二进制与八进制与十六进制，对应转化，不够补0

> [!PDF|red] [[L1-Chap2-数制与编码.pdf#page=29&selection=9,1,27,1&color=red|L1-Chap2-数制与编码, p.29]]
> > 用4位二进制代码对十进制数字符号进行编码，简称为二–十进制代码，或称BCD(Binary Coded Decimal)码。

> [!PDF|red] [[L1-Chap2-数制与编码.pdf#page=29&selection=45,0,63,1&color=red|L1-Chap2-数制与编码, p.29]]
> > BCD码既有二进制的形式，又有十进制的特点。常用的 BCD码有8421码、2421码和余3码。

BCD码分为有权码和无权码，有权码比如8421码，无权码比如余三码

**BCD码一定是四位，注意与普通二进制数的区别，这个是编码，也就是对应的值直接转换，并且一定是4位，0不能省**

> [!PDF|note] [[L1-Chap2-数制与编码.pdf#page=31&selection=12,0,21,0&color=note|L1-Chap2-数制与编码, p.31]]
> > 8421BCD码与十进制数之间的转换是按位进行的，即十进制数的每一位与4位二进制编码对应

> [!PDF|red] [[L1-Chap2-数制与编码.pdf#page=32&selection=18,2,26,2&color=red|L1-Chap2-数制与编码, p.32]]
> > 8421BCD码加3(对应二进制的0011)就可以获得余3码。

#### 2421码！！！
> [!PDF|red] [[L1-Chap2-数制与编码.pdf#page=34&selection=11,1,38,0&color=red|L1-Chap2-数制与编码, p.34]]
> > 1)2421码不具备单值性。例如，0101和1011都对应十进制数字5。为了与十进制字符一一对应，2421码不允许出现 0101～1010的6种状态

> [!PDF|red] [[L1-Chap2-数制与编码.pdf#page=34&selection=40,0,59,1&color=red|L1-Chap2-数制与编码, p.34]]
> > (2)2421码是一种对9的自补代码。即一个数的2421码只要自身按位变反,便可得到该数对9的补数的2421码。

#### 可靠性编码
1. 格雷码/循环码
	掌握二进制数与格雷码之间的转换
2. 奇偶校验码
	由信息位（位数不限）和奇偶检验位（仅有一位）组成
	分为奇校验和偶校验
	出现奇数个错误的时候能检测出来，但是不能确定出错码位的个数和具体位置

### 逻辑函数
#### 由真值表写出逻辑函数的表达式
写与或表达式，不多说了
重点是如何写或与表达式，找到输出为0的式子，如果是0则用原变量，如果是1则用反变量表示

几种形式的变换：
与或式不说了，怎么写或与式，就是我们没有得到1也就是为0的式子用取非的形式用与或的形式写出来之后再用反演律得到，或者说我们说最大项的数就是最小项没取到的，那么针对每个值，如果为0取原变量，如果为1取反变量。

与非与非式直接将与或式两次取反然后里面用一次反演律就得到了

与或非式用与非与非式里面再用反演律然后里面展开得到

或非或非式由或与式两次取反用一次反演律得到

最大项之积一定记得是原变量取0，反变量取1

> [!PDF|red] [[L3-Chap2-逻辑函数的化简.pdf#page=16&selection=98,0,108,4&color=red|L3-Chap2-逻辑函数的化简, p.16]]
> > 同一逻辑函数既可以表示为标准与-或式，也可以表示为标准或- 与式。一个逻辑函数的最小项集合与它的最大项集合，互为补集

卡诺图圈0得到的是反函数的最小项的化简形式

用卡诺图化简最大项之积化为最简或与式:首先先转为最小项之和，取补集就行了，然后圈0得到反函数的最简与或式然后取反就得到了