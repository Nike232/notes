
- 我们可以使用一个 `<script>` 标签将 JavaScript 代码添加到页面中。
- 外部的脚本可以通过 `<script src="path/to/script.js"></script>` 的方式插入。

* 我们可以在代码中编写任意数量的语句。语句之间可以使用**分号**进行分割。
* **虽然js可以将换行符自动理解为分号但是我们尽量能加上就加上避免不确定行为的发生**
* 注释和cpp一样

### 现代特性与use strict
* ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— `"use strict"` 来明确地激活这些特性。
* “use strict”来启用现代特性
* **确保 “use strict” 出现在最顶部**。请确保 `"use strict"` 出现在脚本的最顶部，否则严格模式可能无法启用。只有注释能在use strict的上面，**一旦进入严格模式就没有回头路了**

### 变量 
* **let 变量名 =变量值;**
* 除加了一个let外和python差不多(*动态类型*)
* 注意：对同一个变量进行重复声明会触发 error
* 命名：
1. 变量名称必须仅包含字母、数字、符号 `$` 和 `_`。
2. 首字符必须非数字。
3. 区分大小写
4. 不能是保留字
* **常量：将let换成const**

### 　Number类型
* 特殊数值:Infinity(无穷大) -Infinity NaN(不是一个数)
* 在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 `NaN` 的结果。

### string类型
* 可以用单引号‘’ 双引号"" 反引号
* 反引号是**功能拓展**引号，允许我们将变量和表达式包装在`${...}`之中，来将他们嵌入到字符串中，注意这仅仅在反引号当中有效，其他引号不允许这种嵌入
* 没有char类型

### 布尔类型
* 同cpp和py

### null值
* 相比较于其他编程语言，JavaScript 中的 `null` 不是一个“对不存在的 `object` 的引用”或者 “null 指针”。
* JavaScript 中的 `null` 仅仅是一个代表“无”、“空”或“值未知”的特殊值。

### undefined值
* 特殊值 `undefined` 和 `null` 一样自成类型。
* `undefined` 的含义是 `未被赋值`
* 如果一个变量已被声明，但未被赋值，那么它的值就是 `undefined`

### typeof运算符
* 对 `typeof x` 的调用会以字符串的形式返回数据类型(当然也可以写成typeof (x))

### 几个与用户交互的函数
1. alert 提示消息，**模态窗**，在处理完这个窗口之前是不能与页面的其他部分进行交互的
2. prompt `result=prompt(title,[default]);`浏览器会显示一个带文本消息的模态窗口，还有input框和确认/取消按钮 
	* title 显示给用户的文本
	* default 可选的第二个参数，指定input框里的初始值
	* 我们可以获得用户输入的内容，如果取消输入的话我们会得到null
3. confirm `result=confirm(question)`
带有一个问题和确认/取消两个按钮，确认返回true 取消返回false
这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。

上述所有方法共有两个限制：

1. 模态窗口的确切位置由浏览器决定。通常在页面中心。
2. 窗口的确切外观也取决于浏览器。我们不能修改它。

### 类型转换

有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。

**字符串转换** —— 转换发生在输出内容的时候，也可以通过 `String(value)` 进行显式转换。原始类型值的 string 类型转换通常是很明显的。

**数字型转换** —— 转换发生在进行算术操作时，也可以通过 `Number(value)` 进行显式转换。

数字型转换遵循以下规则：

|值|变成……|
|---|---|
|`undefined`|`NaN`|
|`null`|`0`|
|`true / false`|`1 / 0`|
|`string`|“按原样读取”字符串，两端的空白字符（空格、换行符 `\n`、制表符 `\t` 等）会被忽略。空字符串变成 `0`。转换出错则输出 `NaN`。|

**布尔型转换** —— 转换发生在进行逻辑操作时，也可以通过 `Boolean(value)` 进行显式转换。

布尔型转换遵循以下规则：

|值|变成……|
|---|---|
|`0`, `null`, `undefined`, `NaN`, `""`|`false`|
|其他值|`true`|

上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：

- 对 `undefined` 进行数字型转换时，输出结果为 `NaN`，而非 `0`。
- 对 `"0"` 和只有空格的字符串（比如：`" "`）进行布尔型转换时，输出结果为 `true`。

### 基础运算符
1. 求幂运算 `a ** b` 将 `a` 提升至 `a` 的 `b` 次幂。就像在数学运算中一样，幂运算也适用于非整数。
2. 注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。`alert``(``2` `+` `2` `+` `'1'` `)``;` `// "41"，不是 "221"` `alert``(``'1'` `+` `2` `+` `2``)``;` `// "122"，不是 "14"`
3. 一元运算符加号，或者说，加号 `+` 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 `+` 则会将其转化为数字。
4. 自增/自减只能应用于变量。试一下，将其应用于数值（比如 `5++`）则会报错。

### 值的比较
1. 数值和字符串的比较同cpp
2. **不同类型的比较**:
	* 当对不同的类型进行比较的时候，js会首先转化为数字再进行比较
		`alert("2">1);//true`
		`alert("1"==1);//true`
	 * 对于布尔型，true被转换为1，false被转换为0
	 * 一个有趣的现象
	 `alert(Boolean(0));//false`
	 `alert(Boolean("0"));//true`
	 `0=="0"是因为发生了强制转换，而"0"因为不是空串所以转换为bool类型为true`
3. 因而普通的相等就会出现一些问题，比如不能区分0和false，不能区分""和false;因而引出了严格相等的符号(`===`)就是不进行类型转换，当数据类型不同的时候直接返回false,严格不相等(`!==`)
4. 对null和undefined进行比较:
	* `alert(null===undefined);//false因为不是同一类型`
	 * 特殊的规则`null==undefined`而且**他们仅仅等于对方而不等于其他值**
	 * 当用其他方式进行比较的时候，null被转换为0,undefined被转换为NaN(NaN与任何值比较都是false)

### 空值合并运算符??
* 这是一个新特性
* 写法跟||一样变量a??变量b
* 取值是如果变量a既不是null也不是undefined的时候返回变量a的值，否则返回变量b的值。这个作用也就是相当于当值未定义的时候返回一个默认值
* 与||的区别在于，||只要是假值（不管是false、0、空串）都设置为默认参数，而 ??只有在前面的值是null或者undefined的时候才用默认值,因为其实很多时候0并不是无效值，而是一个有效值
* 它的优先级和||一样，比较低，使用时尽可能使用括号
* 为了安全考虑，js禁止??与&&和||一起使用，除非使用括号明确指定了优先级，否则会触发一个语法错误


### break/continue标签
在一般语法当中,break和continue语句只能跳出当前循环，但是js提供了标签使得可以跳出多重循环
```
outer: for(let i=0;i<3;i++){
	for(let j=0;j<3;j++)
	{
		let input=prompt(`Value at coords (${i},${j})`,``);
		if(!input)break outer;
	}
}
alert('Done!`);
```
上述代码中，`break outer` 向上寻找名为 `outer` 的标签并跳出当前循环。但是无法向下搜寻标签，也就是说标签并不允许跳转到所有位置

### switch语句
基本和cpp差不多
* case分组：这里的分组并不是什么语法，而是利用如果没有break语句会继续执行的特性，我们可以将要共用同一段代码的case写在一起，然后前面的部分都执行空语句，最后一个case里面写代码，这样前面的语句就会依次往下执行到最后一个的代码
* 注意switch语句中的相等是**严格相等**

### 函数
**函数声明**;**function** 函数名（参数列表）{函数体}
除了需要写function关键字以及参数不需要写变量类型而是直接写变量名以外基本和cpp一样（有这个区别的原因在于js是动态类型，不用手动指定数据类型）注意传入的参数相当于值传递
默认值:
* 如果一个函数被调用，但是有参数未被提供，那么相应的值会变成undefined（注意这不是错误）
* 可以用`=`为函数声明中的参数指定默认值
```
function showMessage(from,text="no text given")
{
	alert(from+":"+text);
}
showMessage("Ann");//Ann:no text given
```

返回值：
* 跟cpp一样，只是不用在函数声明的时候指定返回值类型，直接return需要返回的值就可以了。
* 可以return空值，这样可以提前终止函数，也可以没有返回值，这两者的返回值都被看做是undefined
* **注意不要在return和返回值之间添加新行**
```
return 
(xxxxxxx)
```
这是不对的，因为js会默认在return之后添加分号，就相当于
```
return;
(xxxxxx)
```
这样返回值变成了空值
如果想有多行，应该在return的同一行开始写表达式
```
return(
xxxxx
)
```
这是允许的

函数名应该具有描述性，应该能很好地指出这个函数在干什么，并且很重要的是，**一个函数只做好一件事**

### 函数表达式
上面介绍的创建函数的方式是函数声明，跟cpp里面的是类似的
但其实，在js当中，函数并不是一种“神奇的语言结构”,而是**一种特殊的值**
另一种创建函数的方式叫做函数表达式，它允许我们在任何表达式的中间创建一个新的函数
例如：
```
let sayHi=function(){
	alert("Hello");
};//注意这里的分号不是函数的一部分，而是赋值语句的一部分
```
请注意，function关键字后面没有函数名，函数表达式允许省略函数名

**注意，无论函数是如何创建的，函数都是一个值！**
```
function sayHi(){
	alert("Hello");
}
alert(sayHi);
```
在这个例子当中，sayHi变量保存了这个函数的值，我们用alert将这个值打印出来，注意这里没有括号，因此不是函数调用，==结果是会打印出函数代码==
既然是一个值，我们还可以将这个值复制到其他变量，比如以下代码：
```
function sayHi()
{
	alert("Hello");
}
let func=sayHi;//复制函数的值
func();//Hello
sayHi();//Hello
```

再看一个例子：
```
function ask(question,yes,no)
{
	if(confirm(question))yes();
	else no();
}
function showOk()
{
	alert("You agreed");
}
function showCancel()
{
	alert("You canceled");
}
ask("Do you agree?",showOk,showCancel);
//这里函数showOk和showCancel被当作参数传入到ask当中
```
其实还可以更加简洁
function ask(question,yes,no)
{
	if(confirm(question)) yes();
	 else no();
}
ask("Do you agree?",
function(){alert("You agreed");},
function(){alert("You canceled");});
这里直接在调用函数的时候进行函数声明，并且这两个函数没有名字，叫做**匿名函数**，这样的函数在ask之外是无法访问的

**再次强调，一个函数是一个“行为”的值**

**函数表达式是代码执行到达时被创建，并且从那一刻起才能使用，而函数声明，无论写在哪个位置都可以使用，因为在初始化阶段就已经创建**

**严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见.** 但是使用函数表达式可以使得可见，比如以下的例子：
```
let age=prompt("What is your age",18);
let welcome;
if(age<18)
{
	welcome= function()
	{
		alert("Hello");
	};
}
else
{
	welcome=function()
	{
		alert("Greetings");
	};
}
welcome();//可以正常访问
```

在大多数情况下，当我们需要声明一个函数时，最好使用函数声明，因为函数在被声明之前也是可见的。这使我们在代码组织方面更具灵活性，通常也会使得代码可读性更高。

所以，仅当函数声明不适合对应的任务时，才应使用函数表达式