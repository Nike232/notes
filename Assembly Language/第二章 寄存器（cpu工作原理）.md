一个典型的cpu由运算器、控制器、寄存器等器件构成，这些器件靠内部总线连接。

8086cpu有14个寄存器

#### 通用寄存器
8086的所有寄存器都是16位（一个字的长度）的，可以存放两个字节，其中AX、BX、CX、DX四个寄存器通常用来存放一般性的数据，被称为通用寄存器

这个cpu的上一代cpu是八位的，为了兼容，这四个寄存器都可以分为两个独立使用的8位寄存器来使用

比如AX可分为AH（高8位）和AL（低8位），其他同理

#### 几条汇编指令
```
mov ax,18 //ax=18
add ax,8 //ax+=8
mov ax,bx //ax=bx
add ax,bx //ax+=bx
```
如果溢出了，则将舍弃高位
**注意在进行数据传达或运算时，要注意指令的两个操作对象的位数是一致的**

#### 物理地址
所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们把它叫做物理地址

cpu通过地址总线送入存储器的必须是一个内存单元的物理地址

#### 8086cpu给出物理地址的方法
8086有20位地址总线，但是却是16位的cpu，所以如果将地址简单的从内部发出，则最多达到16位宽度，寻址能力只有64kb

8086cpu采用一种在内部将两个16位地址合成的方法来形成一个20位的物理地址

**物理地址=段地址x16+偏移地址**

其中段地址x16其实就是左移4位

其实就是基址＋偏移量的思想，类似于想找一个同学，与其一个一个找，还不如先找到他的班，然后在班上找到他

可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段

#### 段寄存器
段地址存放在段寄存器中，8086cpu有4个段寄存器：CS、DS、SS、ES，目前只介绍CS

### CS和IP
CS为代码段寄存器，IP为指令指针寄存器

**任意时刻，cpu将CS:IP指向的内容当做指令执行

大致的工作过程
1.从CS:IP指向内存单元读取指令，将读取的指令读入指令缓冲器
2.IP=IP+所读指令的长度，从而指向下一个指令
3.执行指令，重复这个过程

#### 修改CS、IP的值
普通的传送指令比如mov不能修改CS、IP的值，能修改他们的值得指令被统称为转移指令，现在介绍一个最简单的可以修改CS、IP的指令：jmp指令

同时修改CS、IP的内容
```
jmp 段地址:偏移地址 //会对应修改
```
只想修改IP的内容
```
jmp 某一合法的寄存器  //将用寄存器中的值修改IP
```

### 代码段
之前将过，可以根据需要，将一组内存单元定义为一个段，因而我们可以将一组代码定义为一个代码段

那么如何让这段代码被执行呢？很明显，就是让CS:IP指向这个代码段的首地址