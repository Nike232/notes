线性表分为数组和链表

### 数组(顺序表)
我们这里要实现的数组一般是动态数组，核心点在于自动扩缩容机制和数据迁移
定义：
```cpp
const int initcap=5;
template <typename T>
class SqList
{
	public:
	T*data;//存放顺序表元素空间的指针
	int capacity;
	int length;
	//基本运算
};
```
重新分配空间大小
```cpp
void recap(int newcap)
{
	if(newcap<=0)return;//判断是否合法
	T*olddata=data;//保存原来的数据
	data=new T[newcap];//开辟新的数据
	capacity=newcap;//更新值
	for(int i=0;i<length;i++)
	{
		data[i]=olddata[i];//迁移数据
	}
	delete []olddata;//删除旧数据
}
```
所以核心在于保存旧数据然后开辟新数据然后数据迁移最后删除旧数据

复制现有数组建表:
```cpp
void CreateList(T a[],int n)
{
	for(int i=0;i<n;i++)
	{
		if(length==capacity)//触发扩容机制
		{
			recap(capacity*2);
		}
		data[length]=a[i];
		length++;
	}
}
```

构造函数
```cpp
SqList()
{
	data=new T[initcap];
	capacity=initcap;
	length=0;
}
```
拷贝构造函数
```cpp
SqList(const SqList<T>&s)
{
	capacity=s.capacity;
	length=s.length;
	data=new T[capacity];
	for(int i=0;i<length;i++)
	{
		data[i]=s.data[i];
	}
}
```
析构函数
```cpp
~SqList()
{
	delete []data;
}
```
将一个元素添加到线性表的末尾
```cpp
void Add(T e)
{
	if(length==capacity)
	{
		recap(capacity*2);
	}
	data[length]=e;
	length++;
}
```
求序号为i的元素
```cpp
bool GetElem(int i,T&e)
{
	if(i<0||i>=length)return false;
	e=data[i];
	return true;
}
```
设置序号为i的元素
```cpp
bool SetElem(int i,T e)
{
	if(i<0||i>=length)return false;
	data[i]=e;
	return true;
}
```
寻找第一个值为e的元素的序号
```cpp
int GetNo(T e)
{
	int i=0;
	while(i<length&&data[i]!=e)i++;
	if(i==length)return -1;
	else return i;
}
```
在线性表中插入e作为第i个元素(平均时间复杂度为O(n))
```cpp
bool Insert(int i,T e)
{
	if(i<0||i>length)return false;//注意可以在末尾进行插入
	if(length==capacity)recap(capacity*2);//根本没有一个位置了，扩容
	//从第i个位置开始往后移动
	for(int j=i;j<length;j++)
	{
		data[j+1]=data[j];
	}
	data[i]=e;
	length++;//别忘了更新值
	return true;
}
```
在线性表中删除第i个元素(平均时间复杂度为O(n))
```cpp
bool Delete(int i)
{
	if(i<0||i>=length)return false;
	//怎么删除直接往前搬迁数据就好了
	for(int j=i;j<length-1;j++)
	{
		data[j]=data[j+1];
	}
	length--;
	//缩容操作
	if(capacity>initcap&&length<=capacity/4)
	{
		recap(capacity/2);
	}
	return true;
}
```

经典算法：见算法整理

### 链表
节点
```cpp
class Node
{
	public:
	int data;
	Node*next;
	Node(){next=nullptr;}
	Node(int v){data=v;next=nullptr;}
};
```
链表有两种建表方式：**头插法和尾插法**

头插法得到的结果是与插入顺序相反的，但是不用设置尾指针

尾插法那么要设立一个尾指针，不然时间复杂度会很高,得到的次序是相同的

一般我们任务头结点和首节点是不一样的，这里的头结点指的是虚拟头结点，首节点也就是第一个有意义的节点，头节点的任务是用来标识整个链表，从头结点开始序列标号为012.....

整个的实现过程就不具体再展开了，自己全部动手实践一遍就好了

但是有几个点要提醒：
1. 一定不要忘记更新遍历的指针，不然会死循环
2. 如果是删除节点，那么一定是一前一后两个指针，这是针对单链表而言的，原因在于，单链表找到了某个节点是得到到前驱节点的
3. 一定要注意指针操作不要混乱了，用最小可行方案想
4. 如果求length，可以直接维护一个值，用空间换时间


双链表：
双链表就是在单链表的基础上加一个前驱节点的指针，在插入删除等操作的时候会方便一些，但是由于要维护的东西变多，所以实际代码难度更大，最常见的错误就是忘记更新，所以用双链表的时候一定要更加小心

与单链表主要操作区别就在于插入和删除，其他都是基本类似的

循环链表：
与非循环链表的区别在于
1. 初始的时候只有头节点head,在循环单链表的构造过程中需要通过head->next=head；来表示是空表
2. 循环单链表在涉及查找操作的表尾判断条件变了，尾结点应该是`p->next=head;`而不是`p->next=nullptr`
删除和插入节点的操作和非循环链表相同

补充：有时或者我们自己写的时候，最好只设置一个尾节点，这样能非常方便的访问首结点和尾结点，在尾部和头部插入新的元素的时间复杂度都是O(1)

循环双链表：
与非循环双链表的区别跟上述基本一致

循环双链表的好处在于可以很方便的找到尾结点，加上双链表的特性，也就是说倒序和正序是一样方便的，这种结构在涉及到对称性问题中会很方便

### 顺序表和链表的比较
1.基于空间考虑
存储密度=节点中数据本身占用的存储量/整个节点占用的存储量
一般存储密度越大，存储空间的利用效率越高

结论很显然

2.基于时间考虑
在于查找和插入删除操作的时间复杂度以及随机存取问题
**结论是多查找用顺序表，多插入删除用链表**

最后注意，线性表示逻辑结构，而顺序表和链表是存储结构，一个是顺序存储一个是链式存储

