串是由**零个**或者多个**字符**组成的有限序列
字串一定要是连续取的
串相等要求长度和各个字符都相等

长度为n的字串的数量n(n+1)/2+1

同样串作为线性表的一种，也是有顺序串和链串的说法，虽然一般都是顺序串

操作和实现基本和顺序表和单链表一样

重点在模式匹配

有两个串s和t，在s中查找与t相等的字串，s叫做目标串，t叫做模式串
成功->找到一个，不成功->没有找到


BF算法就是直接穷举，如果从s0开始匹配不成功，就从s1开始.....

在最好的情况下，时间复杂度为O(m)，也就是刚好第一个次匹配就成功了，最坏情况是O(nxm)
平均情况下时间复杂度为O(nxm)

### KMP算法
基本kmp算法：

第一个关键：求next数组
```cpp
vector<int> GetNext(string t)
{
	int j=0,k=-1;
	vector<int>next(t.size());
	next[0]=-1;
	while(j<t.size()-1)
	{
		if(k==-1||t[j]==t[k])
		{
			next[++j]=++k;
		}
		else k=next[k];
	}
}
```
`j表示正在求next[j]`
`k表示j的前一个位置的最长相等前后缀的长度`

如果等于-1直接各加一
不然如果现在新的匹配成功，`j++;k++;next[j]=k;或者next[++j]=++k;`
如果匹配失败k就退回`next[k]`尝试更短的是否能匹配

kmp算法核心：
```cpp
int KMP(string s,string t)
{
	int n=s.size(),m=t.size();
	vector<int>next=GetNext(t);//得到next数组
	int i=0,j=0;
	while(i<n&&j<m)
	{
		if(j==-1||s[i]==t[j])
		{
			//如果j=-1或者匹配的时候
			i++;j++;
		}//匹配直接两个正常往前走
		else j=next[j];//如果匹配失败了j回退到next[j]
	}
	if(j>=m)return i-m;//匹配成功
	else return -1;//匹配失败
}
```
求next数组的时间复杂度为O(m)（遍历一遍）
总的平均时间复杂度为O(n+m)

基本kmp算法存在的问题，在某些重复结构中优化不足，导致性能退化
比如aaaaaaaaaaaaaab与aaaaab，由于非常重复导致了next数组中的值都很大，会导致多次回退，导致性能退化

既然核心问题在于next数组的值，我们对next数组稍作改进就可以了

原来如果`t[j]==t[k]`就设置`next[++j]=++k;`导致回退缓慢

改进做法
```cpp
vector<int> GetNextval(string t)
{
	vector<int>nextval(t.size());
	nextval[0]=-1;
	int j=0,k=-1;
	while(j<t.size())
	{
		if(k==-1||t[j]==t[k])
		{
			j++;k++;
			if(t[j]!=t[k])
			{
				nextval[j]=k;
			}
			else nextval[j]=nextval[k];
		}
		else k=nextval[k];
	}
}
```
kmp主体算法改为nextval数组就行了,时间复杂度还是为O(n+m)


### 数组
以二维数组为例：分为按行优先存储和按列优先存储

对于一个mxn的矩阵，如果a00的地址LOC(a00)，每一个元素占k个存储单元
如果是按行优先存储，那么LOC（aij)=LOC(a00)+(`i*n+j)xk
如果是按列优先存储，那么LOC(aij)=LOC(a00)+(`j*m+i`)xk

其实这也蕴含着将二维数组的坐标转化为一维数组的索引的方法
二维数组也具有随机存储特性

**看清楚是从0还是从1开始，每一个元素占几个存储单元，是按行优先还是按列优先

### 特殊矩阵的压缩存储
