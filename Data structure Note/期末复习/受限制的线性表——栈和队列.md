栈和队列都是有一定限制的线性表结构，但正因为他们不同的限制，在某些场合变得很好用，同时由于他们的限制所以实现起来并不复杂
### 栈
栈是只能同一端进行插入删除操作的线性表，允许插入删除操作的一端叫做栈顶，另一端叫做栈底。
特点是后进先出

考点一，给定入栈顺序，判断是否是可行的出栈顺序，核心思路在于模拟栈
如果是选择题，直接代入选项手动模拟
如果是代码题，核心代码如下：
```cpp
bool isvalild(vector<int>&ru,vector<int>&chu)
{
	stack<int>st;
	int j=0;//出栈的指针
	for(int i=0;i<ru.size();i++)
	{
		//入栈
		st.push(ru[i]);
		while(!st.empty()&&st.top()==chu[j])
		{
			//出栈
			st.pop();
			j++;
		}
	}
	return st.empty();
}
```
考点二：判断括号是否匹配：
遇到左括号入栈，遇到右括号注意先判断是否为栈空然后看是否匹配

**养成良好习惯，凡是要出栈的时候先判断是否为栈空**

栈可以看作是线性表的一个子集，线性表有顺序表和链表两种实现方式，对应的，栈也有顺序栈和链栈两种实现方式

顺序栈：
用一个数组和一个top指针来实现，为了简单我们直接固定容量，直接开大数组，能满足题目要求就行，没有必要去实现动态数组

初始的时候，`top=-1`表示栈空
栈满:`top==MaxSize-1'
进栈：`top++,data[top]=e`
出栈:`e=data[top];top--`

共享栈问题：
就是两个栈共用一个数组，两个栈指针相向运动
栈1空的条件是`top1=-1` 
栈2空的条件是`top2=M`
栈1满也是栈2满的条件是`top1==top2-1`
然后有了这个的基础，插入和删除操作就正常操作就可以了

链栈：
有一个头节点，将首节点作为栈顶
操作都很简单
主要优势在于一般不需要考虑栈满

基本应用举例：定义一个链栈，在一般功能的基础实现O(1)时间复杂度的返回栈底元素

很明显用基本的链栈是不能满足条件的，需要很方便的访问链表的尾部和头部，可以用不带头节点带rear的循环单链表

栈空：`rear=nullptr`
不考虑栈满
添加元素,在rear后面添加元素
删除，删除rear后面的元素（注意判断是否为空)

然后就是关键的专题：表达式的求值和转换以及栈和递归的转换，放在专题里了

### 队列
先进先出，插入的一端叫队尾，删除的一端叫队首
同样，队列也分为顺序队和链队

顺序队：
用一个数组（为了方便直接取固定长度）和队首和队尾的两个指针来实现

非循环队列：
初始的时候front和rear都为-1(rear=front)
进队rear+1
出队front+1

队空条件`front==rear`
队满条件：`rear==maxsize-1`
进队rear+1
出队front+1

很明显可以看到，front和rear实际上是维护了一个队列区间，但是随着操作的进行，区间不断的向右移动，导致整个对空间的使用效率并不高,（假溢出）

循环队列：
因而为了提高空间使用效率，所以改进成了循环队列
核心是取模运算
把原来的加一改为+1再%maxsize

假如data数组的容量为m,那么队列的状态有m+1种，那么必然产生有两种状态无法区分，所以我们可以规定队列中最多有m-1个元素

在这个前提下，队空的条件是`front==rear`
队满的条件是`(rea+1)%max_size==front`也就是试探进队一次

进队和出队的规则上面已经说了

拓展：front与rear与length之间的关系
已知front与rear,`length=(rear-front+max_size)%max_size`
已知front与length,`rear=(front+length)%max_size`
已知rear与length,`front(rear-length+max_size)%max_size`
所以不一定要用front和rear来作为队列的标识，用任意两个都可以，如果含length的话，就可以直接用length来表示队列的状态,这样设计可以最多保存maxsize个元素

链队：
初始化：`front=rear=nullptr;`
队空：`front=rear=nullptr`，不妨就以`rear==nullptr`作为队空条件
队满：不考虑
进队：在单链表尾部插入元素，并更新队尾指针
出队：取出队首节点并删除

双端队列：（stl中为deque)
两端都可以进行插入和删除，其实就是解除了限制

优先队列：
详细见二叉堆原理、代码以及堆排序




