#### 串的定义
* 串是由*字符*组成的有限顺序序列
* 长度为0的串为空串，仅有空格组成的串叫空白串（注意二者区别）
* 串的比较：**字典序比较**
#### 串的存储
1. 顺序串
2. 链串
具体操作和顺序表以及链表是一样的，特殊性只是在于字符
#### string

1. **构造函数**
   - `string()`：创建一个空字符串。
   - `string(const char* s)`：从C风格的字符串创建一个`std::string`。
   - `string(const string& str)`：复制构造函数。

2. **赋值**
   - `operator=(const string& str)`：将一个字符串赋值给另一个字符串。
   - `assign(const char* s)`：将C风格的字符串赋值给`std::string`。

3. **访问**
   - `operator[]`：通过索引访问字符。
   - `at(size_t pos)`：通过索引访问字符，提供越界检查。
   - `front()`：返回第一个字符。
   - `back()`：返回最后一个字符。

4. **修改**
   - `push_back(char c)`：在字符串末尾添加一个字符。
   - `pop_back()`：移除字符串末尾的字符。
   - `append(const string& str)`：在字符串末尾添加另一个字符串。
   - `insert(size_t pos, const string& str)`：在指定位置插入字符串。
   - `erase(size_t pos, size_t len)`：从指定位置移除指定长度的字符。
   - `replace(size_t pos, size_t len, const string& str)`：替换指定位置和长度的字符为新的字符串。

5. **查找**
   - `find(const string& str, size_t pos = 0)`：从指定位置开始查找子字符串，返回其位置。
   - `rfind(const string& str, size_t pos = npos)`：从后向前查找子字符串，返回其位置。
   - `find_first_of(const string& str, size_t pos = 0)`：查找第一个出现在字符串中的字符。
   - `find_last_of(const string& str, size_t pos = npos)`：查找最后一个出现在字符串中的字符。
   - `find_first_not_of(const string& str, size_t pos = 0)`：查找第一个不在字符串中的字符。
   - `find_last_not_of(const string& str, size_t pos = npos)`：查找最后一个不在字符串中的字符。

6. **大小**
   - `size()` 或 `length()`：返回字符串的长度。
   - `empty()`：检查字符串是否为空。

7. **比较**
   - `compare(const string& str)`：比较两个字符串，返回比较结果。
   - `operator==`, `operator!=`, `operator<`, `operator>`, `operator<=`, `operator>=`：字符串比较操作符。

8. **子串**
   - `substr(size_t pos = 0, size_t len = npos)`：返回从指定位置开始的子字符串。

9. **转换**
   - `c_str()`：返回C风格的字符串。
   - `data()`：返回指向字符串数据的指针。
#### 串的模式匹配（重点）
##### BF算法
![[数据结构教程（C++语言描述）（第2版·微课视频版） (李春葆, 匡志强, 蒋.pdf#page=176&rect=41,247,515,415|数据结构教程（C++语言描述）（第2版·微课视频版） (李春葆, 匡志强, 蒋, p.176]]
暴力算法，当不匹配的时候直接从主串的下一个开始即（i-j+1)然后从匹配串的开头开始匹配。
##### KMP算法
KMP（Knuth-Morris-Pratt）算法是一种用于字符串匹配的高效算法。它通过预处理模式串来避免不必要的比较，从而在最坏情况下也能达到线性时间复杂度 $O(n + m)$，其中 $n$ 是文本串的长度，$m$ 是模式串的长度。

### KMP算法的基本思想

KMP算法的核心思想是利用已经部分匹配的信息来避免从头开始匹配。具体来说，它通过构建一个部分匹配表（也称为前缀函数或“next”数组）来实现这一点。**这个表记录了模式串中每个位置的最长相同前后缀的长度，这样在匹配过程中如果出现不匹配的情况，可以直接跳过已经匹配的部分，从而减少不必要的比较。**

### 部分匹配表（前缀函数）
![[数据结构教程（C++语言描述）（第2版·微课视频版） (李春葆, 匡志强, 蒋.pdf#page=179&rect=47,575,482,677|数据结构教程（C++语言描述）（第2版·微课视频版） (李春葆, 匡志强, 蒋, p.179]]
部分匹配表是一个数组 `next`，其中 `next[i]` 表示模式串 `P` 的前 `i+1` 个字符的最长相同前后缀的长度。例如，对于模式串 `ABCDABD`，其部分匹配表为 `[-1, 0, 0, 0, 0, 1, 2]`。

- `-1` 表示空字符串。
- `0` 表示没有相同前后缀。
- `1` 表示有一个字符的相同前后缀。
- `2` 表示有两个字符的相同前后缀。
### 构建 `next` 数组的步骤

1. **初始化**：
    - `next[0]` 初始化为 `-1`，表示空字符串。
    - `j` 初始化为 `-1`，表示当前匹配的最长前后缀的长度。
    - `i` 初始化为 `0`，表示当前处理的模式串的位置。
2. **迭代构建**：
    - 从 `i = 0` 开始遍历模式串 `P`，直到 `i` 达到模式串的长度。
    - 如果 `P[i] == P[j]`，则 `next[i] = j + 1`，并同时增加 `i` 和 `j`。
    - 如果 `P[i] != P[j]` 且 `j != -1`，则 `j = next[j]`。
    - 如果 `P[i] != P[j]` 且 `j == -1`，则 `next[i] = 0`，并增加 `i`。

### KMP算法的匹配过程

KMP算法的匹配过程如下：

1. 初始化 `i = 0`（文本串的起始位置）和 `j = 0`（模式串的起始位置）。
2. 从 `i` 和 `j` 开始遍历文本串 `T` 和模式串 `P`，直到 `i` 达到文本串的长度。
3. 如果 `T[i] == P[j]`，则同时增加 `i` 和 `j`。
4. 如果 `T[i] != P[j]` 且 `j != 0`，则 `j = next[j]`。
5. 如果 `T[i] != P[j]` 且 `j == 0`，则增加 `i`。
6. 如果 `j` 达到模式串的长度，说明匹配成功，记录匹配位置，并将 `j` 重置为 `next[j]`，继续查找下一个匹配位置。

### 示例

假设我们要在文本串 `ABABDABACDABABCABAB` 中查找模式串 `ABABCABAB`。

1. **构建部分匹配表**：
   - 模式串 `ABABCABAB` 的部分匹配表为 `[-1, 0, 0, 1, 2, 3, 4, 0, 1]`。

2. **匹配过程**：
   - 从 `i = 0` 和 `j = 0` 开始。
   - 逐步比较 `T[i]` 和 `P[j]`，根据部分匹配表调整 `j` 的位置。
   - 最终在 `i = 10` 时，`j` 达到模式串的长度，说明匹配成功，匹配位置为 `10 - 9 = 1`。

KMP算法通过预处理模式串来避免不必要的比较，从而提高了字符串匹配的效率。