## 队列和栈集训刷题

* 队列的精髓在于先进先出，栈的精髓在于先进后出。在刷题的时候要仔细品味这两个特性。
* ![image-20250326215226244](C:\Users\23259\AppData\Roaming\Typora\typora-user-images\image-20250326215226244.png)

这道题肯定就是模拟，遍历一遍字符串，根据每个字符的特性进行单独的处理。我们肯定得需要一个数据结构来存储经过处理后的结果，那么注意到//是返回上一个，也就是把这个数据结构里面的结果最近的那个结果拿出来，这就是栈的效果了。所以也就是所处理的元素要与这个数据结构最近进入的元素进行关联，这就是后进先出。所以拿栈来模拟然后遍历进行处理就可以了。注意我们读取的时候没必要一个一个读，/是分隔标志那就用这个标志来进行读取。

但是注意我们最后是要从前往后读取拼接成结果的，所以只用栈其实不行。但其实我们完全可以拿数组来模拟，记住栈只是一种思想，事实上最基本的数据结构就只是数组和链表，所以只需要自己在操作的时候用一定的操作就可以模拟出栈了。

* ![image-20250326221607379](C:\Users\23259\AppData\Roaming\Typora\typora-user-images\image-20250326221607379.png)

这道题肯定也是遍历然后指针跟着走，主要是单链表是无法倒序进行遍历的，那么恰好栈有后进先出就有倒序这种模样,如果把链表里面的值全部放到一个链表里面那么最后输出的顺序就是倒序排列，那么我们说其实栈只是一种思想一种方法，那么我们底部还是把这个栈看成一个链表，那么其实又变成了两个单链表双指针的问题

* 有效的括号

  经典的栈问题了，因为遍历要处理的是最新的元素，符合栈的特点

  注意一些特殊情况，比如最后栈里面还有元素，或者在匹配时栈为空

* 逆波兰表达式求值

  很经典的问题了，应该已经能熟练掌握了

* 用一个队列来实现栈

  队列和栈是完全相反的操作但是我们可以进行模拟，也就说我先在假如将一个元素加入到队列当中，那么我要求弹出的也是最新加入进去的值，这根插队问题很像，其实也就是通过不断的离队入队将目的元素放在了队头而已

* ![image-20250327151058321](C:\Users\23259\AppData\Roaming\Typora\typora-user-images\image-20250327151058321.png)

很显然又是要遍历，然后要与父路径产生联系，所以我们考虑用栈来保存整个路径，但是呢，由于我们最后只需要返回这个最长路径的长度就可以了，所以我们可以直接存储长度。首先我们要把以\n为分隔符，把这个字符串分割，经典的方法就是使用stringstream+getline然后保存到一个字符串数组里面去。然后遍历这个字符串数组，对于每一个父路径而言（即我们遍历的对象），此刻的栈存放的是之前的所有路径（当然这里是长度），但是我们所需要的只是当前路径的父路径就可以了，比如对于dir2而言你之间的dir1的路径是不需要的，但是由于我们这个字符串的表达式一维的，所以是区分不了的。但是根据规则，比如第一个子路径只有一个\t那就么\t的个数其实就是表示了当前路径的深入的维度，如果当前的维度是1那么栈里面就只应该存在一个父路径，也就是栈里面的元素个数为1。那么多余的元素就应该需要弹出。

那么出现了一个问题，我们把这个多余的元素弹出了，后面也加不回去了，后面的字符串会不会找不到父路径？答案是不会的，原因就在于我们拿到的文件系统本身也就是我们处理字符串的顺序，是从大到小的，在同一个子目录下从大到小的遍历，进入不同的子目录的时候，再也用不到前面的子目录了，这时候把他删去，然后继续从大到小的遍历，所以是没有问题。关键就在于这个顺序上

所以我们需要获得最后一个\t的位置如果是0就是1级子目录，这个我们可以通过rfind来实现。处理完之后，我们就可以把当前路径加入到栈里面了，形成当前情况下的正确路径，那么当遇到了文件，就计算并更新最大值，注意计算的时候还要加上父路径的分隔符最后返回就可以了

但是注意！！！我们最后要访问所有栈中的元素，但是还不能删除，这对于stack是比较麻烦的，所有我们一般遇到栈的问题都可以拿==vector或者deque来模拟实现==，永远记住，栈只是一种思想!

* **最小栈**

  ![image-20250327184232496](C:\Users\23259\AppData\Roaming\Typora\typora-user-images\image-20250327184232496.png)

毫无疑问，这道题的难点就在于如何在常数时间内找到栈中的最小值，因为栈是一个操作受限的一个数据结构，如果我们按照一般的方法想得到一个栈中的最小值，那么肯定就得把所有元素都弹出来才知道谁最小，但这样做的时间复杂度是O(n)肯定是不符合要求的。因而这样的情况下就要想到==用空间换时间==，意思就是在原来栈的基础上我们维护一个什么东西然后方便查询。那么假如我们维护一个栈的最小值，那么当有新的元素进栈的时候，我们只需要比较新的元素和原来的最小值然后更新这个最小值就可以了。但是如果一个元素被弹出了呢，如果被弹出的值比最小值大那肯定还是不变，但如果等于最小值呢，能不能确保他是唯一一个取得最小值的元素呢，答案很明显是不能的，也就是只维护一个最小值是行不通的，那么一个元素进栈他又出栈了，是不是就相当于没有进来过呢，当时的最小值是不是知道的呢，只是我们因为有了进栈的操作然后把最小值给更新掉了，那么我们如果保留原来的最小值不就好了嘛。所以就是对于每一个元素的进栈都维护一个对应的最小值

那么具体该如何去实现呢，我们当然可以创建一个结构体然后，然后把这两个属性绑定在一起，但是更常见的一个做法是类似于memo备忘录一样单独拿一个数据结构来做，因为把两个绑定在一起，增加了原本操作的复杂性。那么这道题我们就拿栈来做就可以了，让这两个栈的操作同步不就实现了。

* ![image-20250327192356682](C:\Users\23259\AppData\Roaming\Typora\typora-user-images\image-20250327192356682.png)

  对于每一个元素我们要维护他对应的频率，这很容易想到用哈希表来实现，然后我们还需要一个整数来记录整个堆栈的最高频率，然后对于同一个频率而言我们还需要找到最接近栈顶的，对于其实也就是最近被添加的，那么我们再维护一个栈，也就是维护一个fre和stack的哈希表即可

  对于每一个元素的加入，首先我们要查找元素-频率这个哈希表当中是否有这个的值如果已经有的话直接对于的值++，没有的话创建并赋值为1，然后我们就能得到最新的这个元素对应的这个频率，拿来和max对比更新值，然后对应的这个频率对应第二个哈希表的队列要把元素push进去，这样就完成了push操作

  对应pop操作稍微有一点不好理解,首先我们肯定要把对应最大频率对应的栈顶元素给弹出并返回，然后我们要把对应元素的频率值给减一，然后重点就是什么时候更新max的值？首先我们第二个哈希表记录的是一个频率对应的栈，那肯定是最大频率对应的栈为空的时候更新max的值，不然肯定就有元素占有这个最大的频率，如何更新？只用把max--就可以了，为什么？因为我们push进一个元素的时候，一个频率值只能加一，也就是如果最大频率为3，那么频率为2为1一定对应着有队列的值，从push这个操作中可以看出来？那有人可能会说这咋可能，比如3331，那么频率为3为最大频率，就没有频率为2的，最后剩下一个频率为1的，注意我们在看的不是第一个哈希表，而是第二个，在添加元素的过程中，当添加第二个3的时候，就把3添加到了频率为2的元素当中，当第三个3出现的时候，频率为3的栈添加了3所有3对应第二个哈希表的存在是123都有，这说明了一定是连续而且没有重复的，所以其实第二个表记录的是对应这个频率的元素有哪些，那么这个最大的频率当中没有元素了，那就该--了到下一个频率里面去找。

* 括号类问题补充习题：
  * ![image-20250327202558918](C:\Users\23259\AppData\Roaming\Typora\typora-user-images\image-20250327202558918.png)

首先这道题直接用上面的括号维护一个栈来进行记录，可以解决，但是时间复杂度比较低，原因就是我们模拟了整个过程但是其实我们最后需要返回的只是一个数字，我们可以直接拿两个数来模拟这个过程，我们假如以左括号为基准定义一个res变量,再定义一个need变量，如果ch是左括号，那么need++就表示对于右括号的需求加一，如果遇到了右括号，那么need--，说明对右括号的需求减一，那么很有可能根本没有需求就会导致need==-1，这个时候意思就是需要添加左括号来弥补，把need清除为0然后res++,也就是说需要插入一个左括号才能抵消掉右括号这一个多余的需求。所以整体思考就是以左括号为基础，看看差了多少个右括号，差了多少个就是要添加的括号，但是也会遇到差负数个这个时候我们就相当于提前虚拟出来了几个左括号先补齐然后再看差了多少个。

* * ![image-20250327203507753](C:\Users\23259\AppData\Roaming\Typora\typora-user-images\image-20250327203507753.png)

这个题就是上面的变种，当然我们直接拿栈来做其实还有点不好做，当然我们可以拿一个数当标记当第二次准备弹出栈顶元素的时候再弹出。然后我们受到上面一道题的启发，直接拿两个数模拟，一个左括号需要两个右括号看看差了几个右括号，不够的左括号先虚拟出来事后再来补

如果need==-1的话那么就需要一个左括号和一个右括号

注意当ch==左括号的时候need+=2肯定是对的，但是如果此时need是奇数个，注意哈need是需求量！说明原来当中有一个多出来的右括号没有匹配完，那么针对这个右括号我们插入一个右括号res++然后对need的需求就减一了，因为这个括号已经匹配了不需要再添加一个了。（res是需要插入的东西，不一定是针对左括号）