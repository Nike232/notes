## 前三章遗漏知识点总结

* 关于单链表、数组和双链表

  首先数组的最大优势是随机访问，但是由于数组一开始就必须划定内存空间，使得数据是有限的因而引发出了扩容和缩容的操作，这也是动态数组的核心。对于增删插改的操作，数组对于查找和修改上有极大的优势，也就是说需求如果主要是查找和修改的时候，数组是第一选择。而对于如果要频繁的进行删除和插入操作，由于涉及到数据迁移，还可能涉及到扩容缩容，数组的效率就不是很高了。

  那么单链表呢，它与数组某种程度上是互补的，首先它不存在容量上的问题。**关于容量**虽然链表不存在容量上的问题，按理说做题的时候最好选择链表，但是由于题目的数据规模一定是有限的，所有创建一个大数组来实现也完全不是问题，而链表的操作出错的可能性比数组大多了，**因而是否有容量限制不是选择数组还是链表的决定因素，还是要看对数据的操作**。那么单链表对于数组有什么优势呢？很明显，查找和修改不是单链表的优势，它们的时间复杂度都是线性的，那么删除和插入操作呢？这得分具体情况，**头部的插入和删除操作时常数复杂度，但是其他地方的插入和删除操作还是线性的**但是对于头部的插入，会造成存储的元素的倒序的还得需要一定的处理，其他地方的插入和删除操作是线性的因为比如删除操作需要查找到需要删除节点的前置节点，查找这部分的时间复杂度是线性的，插入是一样的道理。**所以单链表除了头部的插入和删除操作都是因为先得查找导致时间复杂度是线性的，但是删除和插入操作本身是常数级别的**因而**如果不是只在头部进行插入和删除操作的，其实链表也没啥优势**，那让我们细细想一想，如果单链表的优势智能化在头部体现，这种数据结构不就是栈嘛。然后数组尾部的插入和删除操作也是常数级别。

  **所以可以得出结论，栈的最方便实现办法是数组的尾部和单链表的头部**，当然其实数组的尾部来得更快更好因为空间利用率比较高嘛，而且还比较简单不涉及到指针的操作。

  即然单链表在中间元素的插入和删除操作上没有什么优势，那么双链表能否解决这个问题呢？很遗憾也是不行的，理由就在于只要是链式的存储结构就不具备数组那样的随机访问的优势，那么你访问到目标元素的时间复杂度就是线性的，那双链表比起单链表有什么优化呢？首先单链表我们只维护了一个头节点，那么我们双链表如果维护头节点和尾节点，那么不就能在头部和尾部都能实现高效的插入和删除操作了吗？因而双链表比起单链表的第一个优势就是**头部和尾部都能实现高效的插入和删除操作**，第二个优势在于，单链表如果要插入元素，需要分情况，是插入到左边还是右边，如果是左边的话得找到目标元素的前驱节点（因为每个节点不具备前驱指针）再进行操作，右边的话就直接找目标节点，如果是删除操作的话，也是需要找到目标节点的前驱节点，这些都是因为每个节点只有后驱指针造成的，那么双链表就能解决这个问题。**因而虽然双链表还是改变不了插入和删除的线性时间复杂度（是由链表本身的缺陷决定的）但是可以优化插入和删除本身的操作**。因而如果说我们需要在头部和尾部都有高频率的删除和插入，很显然数组和单链表都不好，那只有双链表来担此大任，并且如果在中间的插入和删除操作的时候涉及到是左边插入还是右边插入的问题，那么也是首选双链表。

  很明显这三种数据结构都没有办法做到常数时间复杂度的插入和删除操作，那么如果非要频繁的插入和删除操作呢，那就只能采用空间换时间的策略。数组可以很快的访问到元素，但是插入和删除操作涉及到数据的搬迁，这是很难改变的。但是链表呢，我们考虑删除和插入操作本身都是常数级别的时间复杂度，问题出在查找元素，那么我们用一个哈希表将位置和节点映射出来不就能实现线性复杂度的查找了嘛。**因而，双链表+哈希表可以实现常数时间复杂度的插入和删除，在频繁地插入和删除的场景里可以考虑**

# 