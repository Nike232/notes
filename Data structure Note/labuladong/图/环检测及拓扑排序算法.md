你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程  `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

很明显，当出现了循环依赖，也就是A课程需要先修B,B课程需要先修A的这种环结构，就不可能修完所有课程

**看到依赖问题，首先想到的就是把问题转化成「有向图」这种数据结构，只要图中存在环，那就说明存在循环依赖**。

很明显，我们把课程当作一个节点，A->B就意味着课程B需要先修A

我们按照这样的方法将所有节点转化为图，然后判断图中是否有环，如果有环那么不可能修完，反之则可以修完

建图就直接用邻接表就行了

现在问题是要判断是否存在环，其实就是在考察遍历所有路径，我们这里先使用DFS

那么如果我当前访问的节点在路径当中已经存在了不就说明有环吗

但是要注意这个图并不一定是一个联通图，因而要用一个for循环将所有节点作为起点调用一次dfs

```cpp
class Solution {
public:
    // 记录递归堆栈中的节点
    vector<bool> onPath;
    // 记录图中是否有环
    bool hasCycle = false;

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph = buildGraph(numCourses, prerequisites);
        
        onPath = vector<bool>(numCourses);
        
        for (int i = 0; i < numCourses; i++) {
            // 遍历图中的所有节点
            traverse(graph, i);
        }
        // 只要没有循环依赖可以完成所有课程
        return !hasCycle;
    }

    // 图遍历函数，遍历所有路径
    void traverse(vector<vector<int>>& graph, int s) {
        if (hasCycle) {
            // 如果已经找到了环，也不用再遍历了
            return;
        }

        if (onPath[s]) {
            // s 已经在递归路径上，说明成环了
            hasCycle = true;
            return;
        }
        
        // 前序代码位置
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // 后序代码位置
        onPath[s] = false;
    }

    vector<vector<int>> buildGraph(int numCourses, vector<vector<int>>& prerequisites) {
        //...
    }
};
```

但是这个解法无法通过所有的测试，会超时。说明**存在冗余计算**

举个例子，假如说我们现在以2为节点遍历所有路径发现没有环，现在我们有一个5->2那么我们是否还要再遍历一遍呢，答案肯定是没必要的

所以如果我们发现有一个节点之前遍历过了，那么就可以直接跳过了

那么现在再进一步，如果不仅要判断是否有环，还要返回这个环中具体有哪些节点？又该怎么做呢

注意onpath当中为true并就一定是我们的环
![](https://pic1.imgdb.cn/item/6826c83858cb8da5c8f5e47e.png)
onpath只是说明从某个节点出发的这条路径上存在环，那么该怎么判断具体环呢？其实很简单我们判断不了的原因是我们只知道哪些是在这个路径当中的，我们没有记录下遍历的顺序，如果我们记录下遍历顺序那就是0 4 5 9 8 7 6 5那么很明显环就是两个相同节点之间的位置

现在问题再进阶一下，返回为了学完所有课程所安排的学习顺序，只需要返回一种，如果不可能完成，那么返回一个空数组

很明显就是拓扑排序的结果，拓扑排序的结果本身就可能有很多种，因而结果自然可能不止一种，那么我们随便返回一种就可以了

那么针对这道题，后序遍历的结果再倒序不就是拓扑排序的结果嘛

**之所以拓扑排序的基础是后序遍历，是因为一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行**。

举二叉树的例子来说，后序位置就是左右子树都遍历完了，才进行遍历，也就是说这个时候是所有的依赖都已经解决了，也只有后序位置才能体现出依赖关系。那么拓扑排序也是一样的，每次选取的时候都是没有依赖的，那么为啥是倒序呢，这是因为拓扑排序是从前往后收集的，而后序位置是从后往前收集的，因而他们虽然都是选取的已经解决好依赖关系的节点，但是是倒序的。

### BFS版本
首先建图还是一样的，dfs是在一个路径中看是否有一个节点重复出现了来判断是否有环。那么BFS该怎么判断呢？

其实BFS版本和我们一开始讲的做拓扑排序的方法一样，如果一个节点没有入度，也就是是起始节点就选他，然后他指向的所有节点的入度都-1，然后完了，我们相当于抹去了这个节点，然后再在这个图中选中没有入度的节点。

这样选中操作循环的操作不就是bfs中的队列操作吗？如果一个节点没有入度就加入队列等待遍历，然后遍历的时候对于目标节点的入度-1，然后如果满足入度=0就加入节点等待遍历，依次循环，直到队列中没有节点。

因而BFS版本的结果就是拓扑排序的结果。

但是怎么判断是否够成环呢？

那我们需要考虑环的入度的情况，如果构成环了，那么环上的节点的入度就肯定不可能为0，所以相当于环中成了一个团体，而你只可能从外面攻破（因为你一开始就必须要选入度为0的节点），就算你把环与外面的节点的联系打破了，内部还是打不破的，始终都有入度。

因而我们只需要在最后来判断是否遍历了所有的节点就可以了