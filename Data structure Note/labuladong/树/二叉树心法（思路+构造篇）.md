二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

---
### 例题一
【翻转二叉树】
首先我们要思考能不能用遍历的思维模式解决问题，如果遍历的话，要思考在每个节点需要做什么，在哪里做？很明显这道题如果用遍历的话就是把每个节点的左右节点进行交换，那我们在前序位置提前保存好左右节点的指针然后进行交换，然后正常的遍历问题就得到了解决。

那么我们再想想分解问题的思路呢？分解问题的关键在于**你要给递归函数一个合适的定义，然后用函数的定义来解释你的代码；如果你的逻辑成功自恰，那么说明你这个算法是正确的。**
我们这道题就不妨直接定义这个递归函数是以某个节点为根节点已经实现了翻转然后返回根节点，注意**这个返回值的设定也很重要**，定义好后就可以根据这个定义在抽象的层面进行操作，现在就是我们得到了一个根节点，我们可以得到两个左右节点为根节点翻转好的节点，那这时候我们直接交换一下左右节点就可以了，当然了要注意base case不然无法结束
### 例题二
【给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树先序遍历顺序相同。】
首先思考这道题能否一遍遍历解决，很显然是可以的，既然要求与先序遍历顺序相同，那我们就在先序位置创建节点然后构造链表就可以了，但这是重新创建节点，能否原地修改呢，遍历的话似乎不行。那我们可以考虑一下分解问题的思维模式

既然要分解问题，就得想一下函数的含义是什么，很简单就是题目的要求，把一个节点作为头节点，然后拉成链表，那现在的问题就在于如果我现在节点的左右节点都已经拉成链表了，怎么把这个节点拉成链表，很简单让左链表的头部放在根节点的尾部，再把右链表的头部放在左节点的尾部就可以了，那我们再加一个递归就可以实现了。

注意一个点就是在得到左节点的尾部的时候，指针不能从左节点开始，应该从根节点开始，虽然看上去没啥区别，但关键在于左节点可能是Null，但是从根节点开始就保证了这种情况，不然就访问了null会造成出错

## 构造二叉树
**二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树**,所以关键就在于找到根节点，然后左子树是啥，右子树是啥，然后先构造出根节点，然后让根节点的left指向左子树，让right指向右子树就可以了。

那左右子树咋构造？递归呗~
