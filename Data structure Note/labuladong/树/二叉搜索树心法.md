二叉搜索树要么用左小右大的性质提高算法效率，要么**利用中序遍历有序这一性质解题**
比如这道题:
给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

如果我们从每个节点应该做什么的角度来想，我们最多能想到把以这个节点所有右子树的值加起来，可是还有他的父节点呢？

所以这道题最好利用中序遍历来解题，原来我们是升序排列，那我们现在需要大于等于的值先出现，其实就是换一下遍历顺序就是了

### 判断BST的合法性
给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

这很容易让我们想到用分解问题的思路，看当前是不是BST,然后看左右子树。

但其实这样是有问题的，因为二叉搜索树的定义是，左子树的**每一个值**都要小于当前值，右子树的**每一个值**都要大于当前值，因而我们只判断了局部，也就是说我们并没有将这个约束条件传递下去，所以我们的函数需要额外的参数也就是最大最小值，然后进行判断

```cpp
    bool _isvalid(TreeNode*root,TreeNode*min,TreeNode*max)
    {
        if(root==nullptr)return true;
        if(min!=nullptr&&root->val<=min->val)return false;
        if(max!=nullptr&&root->val>=max->val)return false;
        return _isvalid(root->left,min,root)&&_isvalid(root->right,root,max);
    }
```
我们还是模拟分解问题的思路，有一个basecase，但是我们加入了min和max的限制条件，对于左子树而言，他们的最大值就是root的当前值，一直对于左子树的左子树而言那么他们的最大值限制又变成了当前值，右子树同理

### 插入一个值
给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

这道题很明显我们可以用分解问题的思路来想，定义一个返回`TreeNode*`的函数也就是插入后的节点，然后进行抽象即可

### 删除一个值
给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

这个比之前的相对来说复杂一些，因为即使找到了这个节点，但是因为要保证最后的二叉搜索树的性质不变所以有几种情况。

首先整体上我们的代码还是递归思路框架不变，在root为nullptr的时候返回nullptr，在root的值等于val的时候，进行删除操作，返回操作后的根节点，如果<和>分别递归调用就行

对于具体的删除，有三种情况
![](https://pic1.imgdb.cn/item/6814868258cb8da5c8d6bc75.png)
第一种：目标节点为叶子节点，直接删除即可
![](https://pic1.imgdb.cn/item/681486c358cb8da5c8d6bc80.png)
第二种，只有一个子节点，那么交换一下然后再删去就可以了
![](https://pic1.imgdb.cn/item/681486f458cb8da5c8d6bca3.png)
第三种，有左右子节点，那么我们需要找到右子树中最小的那个节点(也可以是左子树中最大的那个节点)进行交换，然后再化为第一种情况进行处理

这里对于交换，在算法题中我们可以直接将数据进行交换，比如我们在二叉堆中非常简单的实现，但是在大型的实际的应用当中，我们还是要对指针进行实际交换，因为我们不知道这个数据域里面是什么东西，可能非常大，所以我们还是用指针进行交换

### 不同的二叉搜索树
给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。
```cpp
class Solution {
public:
vector<int>memo;
    int numTrees(int n) {
        memo.resize(n+1,0);
        memo[0]=1;memo[1]=1;
        return traverse(n);
    }
    int traverse(int n)
    {
        if(n==0||n==1)return 1;
        if(memo[n])return memo[n];
        int sum=0;
        for(int i=1;i<=n;i++)
        {
            int left=traverse(i-1);
            int right=traverse(n-i);
            sum+=left*right;
        }
        memo[n]=sum;
        return sum;
    }
};
```
其实就是穷举的思维模式，很明显每一个值都能做根节点，然后左右节点，然后左右子树的可能的情况相乘，然后再把所有情况相加，就可以得到结果了，当然还要使用备忘录消除重复计算