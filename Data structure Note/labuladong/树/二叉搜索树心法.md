二叉搜索树要么用左小右大的性质提高算法效率，要么**利用中序遍历有序这一性质解题**
比如这道题:
给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

如果我们从每个节点应该做什么的角度来想，我们最多能想到把以这个节点所有右子树的值加起来，可是还有他的父节点呢？

所以这道题最好利用中序遍历来解题，原来我们是升序排列，那我们现在需要大于等于的值先出现，其实就是换一下遍历顺序就是了

### 判断BST的合法性
给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

这很容易让我们想到用分解问题的思路，看当前是不是BST,然后看左右子树。

但其实这样是有问题的，因为二叉搜索树的定义是，左子树的**每一个值**都要小于当前值，右子树的**每一个值**都要大于当前值，因而我们只判断了局部，也就是说我们并没有将这个约束条件传递下去，所以我们的函数需要额外的参数也就是最大最小值，然后进行判断

```cpp
    bool _isvalid(TreeNode*root,TreeNode*min,TreeNode*max)
    {
        if(root==nullptr)return true;
        if(min!=nullptr&&root->val<=min->val)return false;
        if(max!=nullptr&&root->val>=max->val)return false;
        return _isvalid(root->left,min,root)&&_isvalid(root->right,root,max);
    }
```
我们还是模拟分解问题的思路，有一个basecase，但是我们加入了min和max的限制条件，对于左子树而言，他们的最大值就是root的当前值，一直对于左子树的左子树而言那么他们的最大值限制又变成了当前值，右子树同理

### 插入一个值
给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

这道题很明显我们可以用分解问题的思路来想，定义一个返回`TreeNode*`的函数也就是插入后的节点，然后进行抽象即可

### 删除一个值
给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

这个比之前的相对来说复杂一些，因为即使找到了这个节点，但是因为要保证最后的二叉搜索树的性质不变所以有几种情况。

首先整体上我们的代码还是递归思路框架不变，在root为nullptr的时候返回nullptr，在root的值等于val的时候，进行删除操作，返回操作后的根节点，如果<和>分别递归调用就行

对于具体的删除，有三种情况
![](https://pic1.imgdb.cn/item/6814868258cb8da5c8d6bc75.png)
第一种：目标节点为叶子节点，直接删除即可
![](https://pic1.imgdb.cn/item/681486c358cb8da5c8d6bc80.png)
第二种，只有一个子节点，那么交换一下然后再删去就可以了
![](https://pic1.imgdb.cn/item/681486f458cb8da5c8d6bca3.png)
第三种，有左右子节点，那么我们需要找到右子树中最小的那个节点(也可以是左子树中最大的那个节点)进行交换，然后再化为第一种情况进行处理

这里对于交换，在算法题中我们可以直接将数据进行交换，比如我们在二叉堆中非常简单的实现，但是在大型的实际的应用当中，我们还是要对指针进行实际交换，因为我们不知道这个数据域里面是什么东西，可能非常大，所以我们还是用指针进行交换

### 不同的二叉搜索树
给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。
```cpp
class Solution {
public:
vector<int>memo;
    int numTrees(int n) {
        memo.resize(n+1,0);
        memo[0]=1;memo[1]=1;
        return traverse(n);
    }
    int traverse(int n)
    {
        if(n==0||n==1)return 1;
        if(memo[n])return memo[n];
        int sum=0;
        for(int i=1;i<=n;i++)
        {
            int left=traverse(i-1);
            int right=traverse(n-i);
            sum+=left*right;
        }
        memo[n]=sum;
        return sum;
    }
};
```
其实就是穷举的思维模式，很明显每一个值都能做根节点，然后左右节点，然后左右子树的可能的情况相乘，然后再把所有情况相加，就可以得到结果了，当然还要使用备忘录消除重复计算

### 不同的二叉搜索树II
给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。

这是要具体生成子树，我们肯定要考虑**分解问题**的思路，对于任何一个i，他都是一个根节点，然后左子树怎么得到呢，就是原问题中的(1-i-1),右子树就是(i+1,n)

所以我们定义函数`vector<TreeNode*>build(int lo,int hi)`就是从lo到hi所生成的结果

接下来就是找base case很明显就是lo>hi的时候返回一个nullptr的数组，其余情况就按照逻辑抽象正常写就可以了

## 后序位置的妙用

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。

**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。

### 二叉搜索子树的最大键值和
给你一棵以 `root` 为根的 **二叉树** ，请你返回 **任意** 二叉搜索子树的最大键值和。

这就是非常经典的与子树有关的问题，所以我们一定要考虑到在后序位置写代码

后序位置的优势是什么？可以得到左右子树的信息，也就是说如果我们需要左右子树的信息，我们也一定要在后序位置写代码。

这道题第一个问题就在于，要找到子树是二叉搜索树，怎么判断是否是二叉搜索树呢？我们最好不要站到整个树的角度去考虑，而是**站在节点的位置去考虑**，这是我们能写出递归函数的重要基础，对于一个节点而言，如果他的任一一个子树不是二叉搜索树，那么他就不是，如果都是，那么还要把左子树的最大值和右子树的最小值拿到，再与根节点的值进行比较，判断整个子树是否是二叉搜索树，既然我们要拿到左右子树的相关信息，那很明显就是要在后序位置写代码了

也就是我们在递归的时候要传递四个值，第一个是是否为二叉搜索树，第二个是最小值，第三个是最大值，第四个是和，那么我们用一个vector<int>来传递就可以了，
