## 后序遍历

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。

**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**！！！

### 例题：
【给你一棵二叉树的根节点 `root` ，返回所有 **重复的子树** 。

对于同一类的重复子树，你只需要返回其中任意 **一棵** 的根结点即可。

如果两棵树具有 **相同的结构** 和 **相同的结点值** ，则认为二者是 **重复** 的。】

首先我们肯定得遍历，对于每一个节点我们要得到他的子树，怎么得到？那肯定只有在后序位置我们才能得到左右子树的信息，然后再加上根节点，就得到了整个子树的信息，如果我们按照左 右 根节点来排序 那么这样的序列就是唯一的就可以代表这颗子树结构和值的信息。

但是要注意的是，我们不能直接按值加进去，因为这样的话就不知道从啥时候开始是左，啥时候开始是右，所以我们采取字符串的形式来表达，中间用left right root 来进行分隔，最后我们再拿哈希表来记录每一种路径所出现的次数，如果重复了就更新值即可

## 序列化与反序列化

**当二叉树中节点的值不存在重复时**：

1. 如果你的序列化结果中**不包含空指针的信息**，且你只给出**一种**遍历顺序，那么你无法还原出唯一的一棵二叉树。
    
2. 如果你的序列化结果中**不包含空指针的信息**，且你会给出**两种**遍历顺序，那么分两种情况：
    
    2.1. 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树。
    
    2.2. 如果你给出前序和后序，那么你无法还原出唯一的一棵二叉树。
    
3. 如果你的序列化结果中**包含空指针的信息**，且你只给出**一种**遍历顺序，也要分两种情况：
    
    3.1. 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树。
    
    3.2. 如果你给出的是中序，那么你无法还原出唯一的一棵二叉树。