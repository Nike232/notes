二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。
### 理解前中后序
* 前序位置的代码在刚刚进入一个二叉树节点的时候执行；
* 后序位置的代码在将要离开一个二叉树节点的时候执行；
* 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。
**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作**。

**仔细观察，前中后序位置的代码，能力依次增强**。

前序位置的代码只能从函数参数中获取父节点传递来的数据。

中序位置的代码不仅可以获取参数数据，还可以获取到左子树通过函数返回值传递回来的数据。

后序位置的代码最强，不仅可以获取参数数据，还可以同时获取到左右子树通过函数返回值传递回来的数据。

所以，某些情况下把代码移到后序位置效率最高；有些事情，只有后序位置的代码能做。
**一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。
一道例题：
【给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。】
首先我们站在一个节点上思考，以该节点为根节点的左节点的最大深度加上右节点的最大深度就是直径，所以我们要求的就是每个节点的直径的最大值，很直观的想法就是遍历一遍二叉树直接求出每一个节点的直径，然后更新最大值。这样固然是正确的，但是效率比较低，原因在于求最大深度的时候也是在遍历，我们每一个节点都要进行一次遍历。但是我们如果仔细想想，我们在求最大深度用的是递归遍历，也就是在后序位置我们已经能拿到左右节点的最大深度了，这个时候我们就可以直接更新值了，那么就没有必要专门去遍历然后每一次都去求一个最大深度了，我们在求最大深度的时候就直接在后序位置更新值即可。
**反过来，如果你写出了类似一开始的那种递归套递归的解法，大概率也需要反思是不是可以通过后序遍历优化了。**