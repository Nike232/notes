我们在数组双指针中讨论过关于回文串的相关事情，首先最简单的判断是否是回文串，两个指针向中间逼近，然后是寻找回文串，我们使用的是中心拓展法

链表和数组都是顺序存储结构有相似之处，首先我们来判断一个链表是否为回文链表，如果用双指针的问题在于，不能向前走

第一个解决方案是使用栈，得到倒序的链表然后进行判断，这个的时间复杂度和空间复杂度都是O(n)


首先我们的时间复杂度肯定最优是O(n),但是能不能像数组那样原地进行比较呢，也就是能不能做到时间复杂度为O(1)呢？

答案是可以的

我们如果可以将后面一半的链表进行反转，然后再比对，那么空间复杂度就是O(1)了，如何得到中间节点？就是之前快慢指针的技巧，反转链表也是之前讲过的

```cpp
    bool isPalindrome(ListNode* head) {
        ListNode*fast=head,*slow=head;
        while(fast!=nullptr&&fast->next!=nullptr)
        {
            fast=fast->next->next;
            slow=slow->next;
        }
        if(fast!=nullptr)slow=slow->next;//说明是奇数个
        ListNode*newhead=reverse(slow);
        ListNode*p=head;
        while(newhead!=nullptr)
        {
            if(newhead->val!=p->val)return false;
            newhead=newhead->next;p=p->next;
        }
        return true;
    }
    ListNode*reverse(ListNode*head)
    {
        if(head==nullptr||head->next==nullptr)return head;
        ListNode*nxt=reverse(head->next);
        head->next->next=head;
        head->next=nullptr;
        return nxt;
    }
```
用快慢指针找到中间节点，如果是奇数个slow再进一步，然后翻转链表，依次比对

这样虽然做到了空间复杂度为o(1),但是修改了原本的链表

那么能不能不修改原来的链表呢？
![](https://pic1.imgdb.cn/item/681aedeb58cb8da5c8e1ffe0.png)
那么其实只需要保存这两个节点的位置，然后在返回之前再翻转回来再连接上就可以了