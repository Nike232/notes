首先先是最基础的也就是反转整个单链表，我们先用最容易想到的迭代来做

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==nullptr)return nullptr;
       ListNode*pre,*p,*nex;
       pre=head;p=pre->next;pre->next=nullptr;
       while(p!=nullptr)
       {
        nex=p->next;
        p->next=pre;
        pre=p;
        p=nex;
       }
       return pre;
    }
};
```
有一个需要注意的地方，**凡是涉及到要访问next指针的地方都应该先考虑是否为nullptr**，二叉树也是这样

下面是递归解法：
```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==nullptr||head->next==nullptr)return head;
        ListNode*nex=reverseList(head->next);
        head->next->next=head;
        head->next=nullptr;
        return nex;
    }
};
```
![](https://pic1.imgdb.cn/item/68199cbf58cb8da5c8deee59.png)

很明显是分解问题的思路，注意递归的时候不要陷入递归的细节，而是抓住抽象和找准base case

现在稍微进阶一点，如果要反转前n个节点呢
![](https://pic1.imgdb.cn/item/6819be2e58cb8da5c8dfcbe3.png)
首先用迭代跟之前的思路差不多，而对于递归需要注意的是，我们需要一个外部变量来保存后面的节点（比如）上面例子中的4,至于思路则是和之前的代码差不多

```cpp
    ListNode*reverseN(ListNode*head,int n)
    {
        if(head==nullptr||head->next==nullptr)return head;
        ListNode*pre,*cur,*nxt;
        pre=nullptr;cur=head;nxt=head->next;
        while(n>0)
        {
            cur->next=pre;
            pre=cur;
            cur=nxt;
            if(nxt!=nullptr)nxt=nxt->next;
            n--;
        }
        head->next=cur;
        return pre;
    }
```
迭代算法，可以看到pre一开始为nullptr就使得情况一般化了，最后head变成了尾结点，需要和cur连接，然后pre是头结点应该返回

再看一下递归解法
```cpp
    ListNode*last;
    ListNode*reverseN(ListNode*head,int n)
    {
        if(n==1)
        {
            last=head->next;
            return head;
        }
        ListNode*nxt=reverseN(head->next,n-1);
        head->next->next=head;
        head->next=last;
        return nxt;
    }
```
重点在于需要保存不翻转的第一个节点方便头结点（现在的尾节点）来连接，其余的都和之前的差不多

### k个一组翻转链表
给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

我们肯定不会真的一组一组去翻转，而是要用分解问题的思路去解决，由于链表天然具有递归的特性，翻转2组跟翻转n组其实没有什么太大的区别。那么我就要聚焦于1.base case 2.把子问题和当前问题联系起来

首先是base case那肯定是只能翻转一组或者不能翻转的情况，我们派一个指针去探路，做一个for循环看中间是否已经到达nullptr这种情况就是不用翻转，直接返回，第二种情况就是能翻转一组，那么这就跟之前的翻转前n个契合上了，直接调用就行，那么后面的呢，那我们要把翻完这一组后面的第一个指针传进去，这不就刚好是我们之前的探路指针吗，那么再连接一下就可以了
