* 二叉树只有**递归遍历**和**层序遍历**这两种，再无其他。递归遍历可以衍生出 DFS 算法，层序遍历可以衍生出 BFS 算法。
* 递归遍历二叉树节点的顺序是固定的，但是有三个关键位置，在不同位置插入代码，会产生不同的效果。
* 层序遍历二叉树节点的顺序也是固定的，但是有三种不同的写法，对应不同的场景。
### 递归遍历（DFS）
* 递归遍历节点的顺序**仅取决于左右子节点的递归调用顺序，与其他代码无关**
```
// 二叉树的遍历框架
void traverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 前序位置
    traverse(root->left);
    // 中序位置
    traverse(root->right);
    // 后序位置
}
```
* **所谓的前、中、后序遍历，只不过是在不同的位置进行处理**，插入其他代码，整个递归遍历整个树的顺序只取决于调用tarverse，那么从左到右还是从右到左其实只取决于递归的调用顺序
![](https://pic1.imgdb.cn/item/67f7426f88c538a9b5c83950.jpg)
**前序位置的代码会在进入节点时立即执行；中序位置的代码会在左子树遍历完成后，遍历右子树之前执行；后序位置的代码会在左右子树遍历完成后执行**

---
### 层序遍历(BFS)
顾名思义，就是一层一层地遍历
![](https://pic1.imgdb.cn/item/67f76c3e88c538a9b5c853a1.jpg)
层序遍历需要借助队列来实现，而且根据不同的需求，可以有三种不同的写法，下面一一列举。
一层一层的遍历可以想到之前用队列来实现杨辉三角，其实也是一层一层地遍历，二者有一定的共同之处
写法一：
```
void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    std::queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        TreeNode* cur = q.front();
        q.pop();
        // 访问 cur 节点
        std::cout << cur->val << std::endl;
        
        // 把 cur 的左右子节点加入队列
        if (cur->left != nullptr) {
            q.push(cur->left);
        }
        if (cur->right != nullptr) {
            q.push(cur->right);
        }
    }
}
```
* 这种写法最大的优势就是简单。每次把队头元素拿出来，然后把它的左右子节点加入队列，就完事了。但是这种写法的缺点是，无法知道当前节点在第几层。知道节点的层数是个常见的需求，比方说让你收集每一层的节点，或者计算二叉树的最小深度等等。所以这种写法虽然简单，但用的不多，下面介绍的写法会更常见一些。
写法二：
```
void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<TreeNode*> q;
    q.push(root);
    // 记录当前遍历到的层数（根节点视为第 1 层）
    int depth = 1;

    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode* cur = q.front();
            q.pop();
            // 访问 cur 节点，同时知道它所在的层数
            cout << "depth = " << depth << ", val = " << cur->val << endl;

            // 把 cur 的左右子节点加入队列
            if (cur->left != nullptr) {
                q.push(cur->left);
            }
            if (cur->right != nullptr) {
                q.push(cur->right);
            }
        }
        depth++;
    }
}
```
* 注意size是随时在变的要提前记录下来
写法三：
```
class State {
public:
    TreeNode* node;
    int depth;

    State(TreeNode* node, int depth) : node(node), depth(depth) {}
};

void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<State> q;
    // 根节点的路径权重和是 1
    q.push(State(root, 1));

    while (!q.empty()) {
        State cur = q.front();
        q.pop();
        // 访问 cur 节点，同时知道它的路径权重和
        cout << "depth = " << cur.depth << ", val = " << cur.node->val << endl;

        // 把 cur 的左右子节点加入队列
        if (cur.node->left != nullptr) {
            q.push(State(cur.node->left, cur.depth + 1));
        }
        if (cur.node->right != nullptr) {
            q.push(State(cur.node->right, cur.depth + 1));
        }
    }
}
```
**这样每个节点都有了自己的 `depth` 变量，是最灵活的，可以满足所有 BFS 算法的需求**。但是由于要额外定义一个 `State` 类比较麻烦，所以非必要的话，用写法二就够了。这种边带有权重的场景属于图结构算法，在之后才会用到这种写法。
### 其他遍历？

二叉树的遍历方式只有上面两种，也许有其他的写法，但都是表现形式上的差异，本质上不可能跳出上面两种遍历方式。

比方说，你可能看到用栈来迭代遍历二叉树的代码。但这本质还是是递归遍历，只不过他手动维护栈模拟递归调用罢了。

再比如，你还可能看到递归地一层层遍历二叉树的代码。但这本质还是层序遍历，只不过他把层序遍历代码中的 for 循环用递归的形式展现了。

总之，不要被表象迷惑，二叉树的遍历方式就上面两种，其他的只是表面上发生了改变。

### 应用
在实际的算法问题中，**DFS 算法常用来穷举所有路径，BFS 算法常用来寻找最短路径**
一道例题：
```
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明:叶子节点是指没有子节点的节点
```
如果用dfs做的话，就要遍历所有的路径，在过程中进行比较和值的更新，但是用bfs的话第一次遇到nullptr的时候就一定是最短路径了。所有bfs适合求最短路径。
而对于求所有路径来说，dfs天然适合求所有路径。
### 多叉树的遍历
和二叉树的遍历非常类似，只是原来只有两个的，现在改成个数组罢了