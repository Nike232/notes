### 选择排序
很简单，就是找到一个数组中最小的元素然后与第一个元素交换，然后找第二小的元素......
```cpp
void sort(vector<int>& nums) {
    int n = nums.size();
    int sortedIndex = 0;
    while (sortedIndex < n) {
        // 找到未排序部分 [sortedIndex, n) 中的最小值
        int minIndex = sortedIndex;
        for (int i = sortedIndex + 1; i < n; i++) {
            if (nums[i] < nums[minIndex]) {
                minIndex = i;
            }
        }
        // 交换最小值和 sortedIndex 处的元素
        int tmp = nums[sortedIndex];
        nums[sortedIndex] = nums[minIndex];
        nums[minIndex] = tmp;

        // sortedIndex 后移一位
        sortedIndex++;
    }
}
```
这个排序是原地排序，空间复杂度为O(1),时间复杂度为O(n^2)

同时这个排序是不稳定排序

还有一个问题就是，就算这个输入的数组已经有序了，那么还是会执行这么多操作，也就是时间复杂度仍然是O(n^2)),这也是一个比较大的问题

### 冒泡排序
选择排序之所以没有稳定性是因为我们直接将最小值和原本位置的值进行了交换，如果要保持稳定性，正确的做法应该是模拟数组插入数据的操作，将最小值放在该放的位置后，后面的值进行移动再把原来的值放进去以保持其他数据的相对顺序不变，但这样时间复杂度将更加复杂。

冒泡排序可以解决这个问题，冒泡排序是从后往前看，如果遇到了逆序的情况，就交换相邻两个的值，这样如果数值相同的就不会改变顺序，同时还可以将最小值/最大值往前顶，这也是为什么叫冒泡排序。
```cpp
void sortVector(vector<int>& nums) {
    int n = nums.size();
    int sortedIndex = 0;
    while (sortedIndex < n) {
        // 寻找 nums[sortedIndex..] 中的最小值
        // 同时将这个最小值逐步移动到 nums[sortedIndex] 的位置
        for (int i = n - 1; i > sortedIndex; i--) {
            if (nums[i] < nums[i - 1]) {
                // swap(nums[i], nums[i - 1])
                int tmp = nums[i];
                nums[i] = nums[i - 1];
                nums[i - 1] = tmp;
            }
        }
        sortedIndex++;
    }
}
```
针对选择排序已经是有序的数组仍然要执行O(n^2)的操作的问题，冒泡排序可以解决，很简单，只要你在第一轮冒泡的过程中没有交换不就说明已经有序了嘛，因而我们可以用一个变量来记录是否进行了交换，如果没有，那么第一次冒泡后我们就可以提前终止排序

但是冒泡排序的时间复杂度仍然是O(n^2)

### 插入排序
之前我们选择排序的算法是在剩余未排序的数中找到最小值然后添加到已经排序的数组

那么我们能不能反过来，就是我们已经维护了一个排序的数组，看新添加的这个数应该插入到这个排序的数组的哪里，那我们就从最后往前遍历，如果是逆序，就交换

```cpp
void sort(vector<int>&nums)
{
	int n=nums.size();
	int sortedIndex=0;
	while(sortedIndex<n)
	{
		for(int i=sortedIndex;i>0;i--)
		{
			if(nums[i]<nums[i-1])
			{
				swap(nums[i],nums[i-1]);
			}
			else break;//注意这里如果已经是正序了，肯定就不用再交换了
		}
		sortedIndex++;
	}
}
```
很明显，只可能交换两个相邻的值，因而是稳定排序。
空间复杂度为O(1)，为原地排序，时间复杂度为O(n^2)

很显然，这个算法的好处在于，初始的数组越有序，时间复杂度越低，因而**排序算法的综合性能是优于冒泡排序的**

### 希尔排序
#### h有序数组
```cpp
nums:
[1, 2, 4, 3, 5, 7, 8, 6, 10, 9, 12, 11]
 ^--------^--------^---------^
    ^--------^--------^---------^
       ^--------^--------^----------^

 1--------3--------8---------9
    2--------5--------6---------12
        4--------7--------10---------11
```
这是一个3有序数组，也就是每隔2个元素的排序是有序的

所以当一个数组完成排序的时候也就是1有序数组

希尔排序的思路就是

先把乱序数组变成一个 `16` 有序数组，然后再变成 `8` 有序数组，`4` 有序数组，`2` 有序数组，最后变成 `1` 有序数组，完成排序。

这个 `1, 2, 4, 8, 16...` 的序列称之为「递增函数」
```cpp
// 希尔排序，对 h 有序数组进行插入排序
// 逐渐缩小 h，最后 h=1 时，完成整个数组的排序
void sort(vector<int>& nums) {
    int n = nums.size();
    // 我们使用的生成函数是 2^(k-1)
    // 即 h = 1, 2, 4, 8, 16...
    int h = 1;
    while (h < n / 2) {
        h = 2 * h;
    }
    // 改动一，把插入排序的主要逻辑套在 h 的 while 循环中
    while (h >= 1) {
        // 改动二，sortedIndex 初始化为 h，而不是 1
        int sortedIndex = h;
        while (sortedIndex < n) {
            // 改动三，把比较和交换元素的步长设置为 h，而不是相邻元素
            for (int i = sortedIndex; i >= h; i -= h) {
                if (nums[i] < nums[i - h]) {
                    // swap(nums[i], nums[i - h])
                    int tmp = nums[i];
                    nums[i] = nums[i - h];
                    nums[i - h] = tmp;
                } else {
                    break;
                }
            }
            sortedIndex++;
        }

        // 按照递增函数的规则，缩小 h
        h /= 2;
    }
}
```
希尔排序的性能和递增函数的选择有很大关系，上面的代码中我们使用的递增函数是 2k−12k−1，因为这是最简单的，但这并不最优的选择。

建议把 (3k−1)/2(3k−1)/2 作为递增函数来写希尔排序的代码，这种写法的效率相对较高。

希尔排序的空间复杂度为O(1)是原地排序算法，但是是不稳定算法，因而很明显因而交换的不是相邻元素，所以很可能会改变原来的顺序

希尔排序的时间复杂度主要取决于递增函数的选择，但肯定的是**希尔排序的算法复杂度小于O(n^2)**
