### 快速排序
快速排序的基本思路：
1.在nums数组中随意选择一个元素作为切分元素（一般选择第一个元素）
2.对数组中的元素进行一系列的交换操作，小于切分元素的放在切分元素左边，大于的放在右边
3.递归地对切分元素左边和右边的数组执行上面的操作

所以核心思想就是：**先对一个排好序，再对其他排好序**

很明显，快速排序的过程其实就是构造一颗BST的过程，那么自然的树高就很重要，如果不平衡的话，那么时间复杂度将大大提高

为了避免这种情况，需要提高随机性

常见的方法是在排序之前对整个数组用洗牌算法进行打乱，或者在partiton函数中随机选择数组元素作为切分点。

代码实现：
```cpp
class Quick
{
	public:
	static void sort(vector<int>&nums)
	{
		shuffle(nums);//先随机打乱，避免出现耗时的极端情况
		sort(nums,0,nums.size()-1);
	}
	private:
	static void sort(vector<int>&nums,int lo,int hi)
	{
		if(lo>=hi)return;
		//对nums[lo,hi]进行切分
		int p=partition(nums,lo,hi);
		sort(nums,lo,p-1);
		sort(nums,p+1,hi);
		//对左右子数组进行排序
	}
	static int partition(vector<int>&nums,int lo,int hi)
	{
		int pivot=nums[io];//选取第一个元素作为切分元素
		int i=lo+1,j=hi;
		while(i<=j)
		{
			while(i<hi&&nums[i]<=pivot)i++;//此while结束时nums[i]恰好>pivot
			while(i>lo&&nums[j]>pivot)j--;//此while结束时nums[j]恰好<=pivot
			if(i>=j)break;
			swap(nums[i],nums[j]);
		}
		swap(nums[lo],nums[j]);
		return j;
	}
	static void shuffle(vector<int>&nums)//洗牌算法
	{
		srand((unsigned)time(NULL));
		int n=nums.size();
		for(int i=0;i<n;i++)
		{
			int r=i+rand()%(n-i);
			swap(nums[i],nums[r]);
		}
	}
};
```

理想的时间复杂度是O(NlogN)

空间复杂度是递归堆栈的深度，也就是树高O(logN)

注意，快速排序是不稳定排序，与之相对应的归并排序是稳定排序

### 归并排序
归并排序就是二叉树的后序排序

归并排序就是先把左半边的数组排好序，再把右半边的数组排好序，然后再合并

所以这就不难理解为什么是后序位置排序了

```cpp
class Merge
{
	private:
	static vector<int>temp;//用于辅助合并有序数组
	public:
	static void sort(vector<int>&nums)
	{
		temp.resize(nums.size());
		sort(nums,0,nums.size()-1);
	}
	private:
	static void sort(vector<int>&nums,int lo,int hi)
	{
		if(lo==hi)return;//单个元素，base case
		int mid=lo+(hi-lo)/2;
		sort(nums,lo,mid);
		sort(nums,mid+1,hi);
		merge(nums,lo,mid+1,hi);//将两部分的有序数组合并为一个有序数组
	}
	static void merge(vector<int>&nums,int lo,int mid,int hi)
	{
		//合并两个有序数组就是双指针技巧
		//先把nums[lo...hi]的结果复制到辅助数组中
		//以便合并后的结果能直接存入nums
		for(int i=lo;i<=hi;i++)
		{
			temp[i]=nums[i];
		}
		int i=lo,j=mid+1;
		for(int p=lo;p<=hi;p++)
		{
			if(i==mid+1)//左半边数组已经完全合并
			{
				nums[p]=temp[j++];
			}
			else if(j==hi+1)//右半边数组已经完全合并
			{
				nums[p]=temp[i++];
			}
			else if(temp[i]>temp[j])
			{
				nums[p]=temp[j++];
			}
			else nums[p]=temp[i++];
		}
	}
};
```

归并排序是稳定排序

时间复杂度为O(NlogN)

归并排序不是原地排序，需要一个辅助数组