二叉搜索树(BST)的特点是左小右大：每一个节点的左子树的**每一个值**都比当前节点值小，右子树的**每一个值**都比当前节点值大

应用场景主要在快速搜索某一个节点，时间复杂度为O(logn)

### TreeMap/TreeSet实现原理
跟据名字可以看出其和哈希表/哈希集合的结构是相似的，TreeSet是对TreeMap的简单封装，就跟HashSet和HashMap的关系一样
```
template<typename K,typename V>
class TreeNode
{
	public:
	K key;
	V val;
	TreeNode<K,V>*left,*right;
	TreeNode(K key,V val):key(key),val(val),left(nullptr),right(nullptr){}
};
```
实现原理：

#### 基本增删查改
1. 最基本的get
```
TreeNode *target=nullptr;
void traverse(TreeNode*root,int target)
{
	if(root==nullptr)return;
	if(root->val==target)target=root;
	if(!target)return;//如果已经找到了就无需再找了
	if(root->val<target)traverse(root->right,target);
	else traverse(root->left,target);
}
```
2. put remove containKey,都是基于get方法上做一点小改动，时间复杂度仍然为O(logn)(具体代码在code里面实现)
3. floorkey和ceilingkey方法是查找小于等于/大于等于某个键的最大/最小值，实现和get基本类似，唯一的区别在于当查找不到目标值的时候，get会返回nullptr，而这两个会返回离他最近的最大/最小值
4. rangekeys方法是输入一个`[low,hi]`区间，返回这个区间内的所有值，还是要利用bst的特性，当当前的值小于low的时候，左子树就不用搜了，当当前的值大于hi的时候，右子树就不用搜了
5. firstKey和lastKey分别返回最小和最大键，很简单，一直往左走最后一个非空节点的值就是最小值，同样一直往右走，最后一个非空节点的值就是最大值
6. keys方法返回所有键并且结果有序，用中序遍历即可，因为中序遍历的结果是LCR刚好对应了小中大的有序
#### selectKey,rank方法
selectKey是查找排名为k的键(从小到大，从1开始),rank方法是查找目标键的排名。

很容易想到的是用中序遍历，数到第k个的时候返回，时间复杂度为O(k)

还有一种更加巧妙的方法，还是以空间换时间的思路，给每个节点记录下size(以当前节点为根节点的子树的节点总数(包含当前节点))
```
    7
   / \
  4   9
 / \   \
1   5   10

keys [1, 4, 5, 7, 9, 10]
rank  1  2  3  4  5  6
size  1  3  1  6  2  1
```
**根据BST左小右大的特性，只要知道了左子树的节点个数，也就知道了当前节点的排名**
知道了自己的排名，也就知道了目标排名的值是位于左子树上还是位于右子树上

比如说查找上面例子中排名为3的节点，首先看根节点他的排名是左子树节点数+1，也就是4，我们要找排名为3的就要到左子树上去找，然后看4的排名为1的节点数+1也就是2，那我们知道了要去右子树去找，然后找到了5就找到了

这种方法的时间复杂度为O(logk)

再说rank方法，比如rank(9),我们想知道值为9排名第几，我们先来到了7,9大于7，所以我们递归调用右子树去找，右子树找到的结果再加上7的排名也就是最终结果了

当然这样也提高了维护的复杂性，因为每次插入和删除节点都需要动态更新size值，来确保正确性

### 性能问题
BST的时间复杂度之前说是O(logn),这是有前提的，即二叉搜索树要是**平衡**的，也就是左右子树的高度差不能太大
```
1
 \
  2
   \
    3
     \
      4
       \
        5
```
比如像这样，虽然满足BST的定义，但其实已经退化成了一条单链表，在不结合哈希表的情况下，查找的时间复杂度只能是O(n)

因而可以说，**二叉搜索树的性能取决于树的高度，树的高度取决于树的平衡性**，因此，在实际应用当中，TreeMap需要自动维护树的平衡性，避免出现性能退化

比如上面那个单链表，可以被旋转成比较平衡的二叉搜索树
```
    3
   / \
  2   4
 /     \
1       5
```
具体该如何自平衡，不在目前的探讨范围之内

### 红黑树
红黑树是自平衡的二叉搜索树，它的树高在任何时候都能保持在logn，这样就可以保证增删查改的时间复杂度是O(logn),而不会像之前的例子退化成O(n),不过完美平衡的代价是红黑树的代码实现比较复杂，在此不会深入红黑树的代码细节，如果需要使用TreeMap/TreeSet，直接调用标准库就可以了