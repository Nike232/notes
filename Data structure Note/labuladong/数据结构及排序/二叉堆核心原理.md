**二叉堆是一种能够动态排序的数据结构**

二叉堆的主要操作就两个，`sink`（下沉）和 `swim`（上浮），用以维护二叉堆的性质。

二叉堆的主要应用有两个，首先是一种很有用的数据结构优先级队列（Priority Queue），第二是一种排序方法堆排序（Heap Sort）。

### 二叉堆的性质
二叉堆就是一种能够动态排序的数据结构。所谓动态排序，就是说我们可以不断往数据结构里面添加或删除元素，数据结构会自动调整元素的位置，使得我们可以有序地从数据结构中读取元素，这是一般的排序算法做不到的。

能动态排序的常用数据结构其实只有两个，一个是优先级队列（底层用二叉堆实现），另一个是二叉搜索树。二叉搜索树的用途更广泛，优先级队列能做的事情，二叉搜索树其实都能做。但优先级队列的 API 和代码实现相较于二叉搜索树更简单，所以一般能用优先级队列解决的问题，我们没必要用二叉搜索树。

你可以认为二叉堆是一种特殊的二叉树，这棵二叉树上的任意节点的值，都必须大于等于（或小于等于）其左右**子树所有节点**的值。如果是大于等于，我们称之为「大顶堆」，如果是小于等于，我们称之为「小顶堆」。

对于小顶堆，每个节点下方的所有节点的值都比它大，那么不难想象根节点就是整棵树上的最小值。同理，大顶堆的根节点就是整棵树上的最大值。所以二叉堆可以辅助我们快速找到最大值或最小值。

二叉堆还有个性质：一个二叉堆的左右子堆（子树）也是一个二叉堆。

### 最常见的应用:优先级队列
```cpp
class MyPriorityQueue {
public:
    // 在二叉堆堆顶插入一个元素，时间复杂度 O(logN)
    // N 为当前二叉堆中的元素个数
    void push(int x);

    // 返回堆顶元素，时间复杂度 O(1)
    // 该堆顶元素就是二叉堆中的最大值或最小值，取决于是最大堆还是最小堆
    int peek();

    // 删除堆顶元素，时间复杂度 O(logN)
    int pop();

    // 返回堆中元素的个数，时间复杂度 O(1)
    int size();
};
```

### 另一种应用：堆排序
原理特别简单，就相当于把一个乱序的数组都 `push` 到一个二叉堆（优先级队列）里面，然后再一个个 `pop` 出来，就得到了一个有序的数组

当然，正常的堆排序算法的代码并不依赖优先级队列，且空间复杂度是 O(1)O(1)。那是因为它把 `push` 和 `pop` 的代码逻辑展开了，再加上直接在数组上原地建堆，这样就不需要额外的空间了。

具体的代码实现后面会了解