一幅图是由**节点**和**边**构成的，如下图
![](https://pic1.imgdb.cn/item/681b7dc658cb8da5c8e3df91.png)
那么每一个节点的属性就应该有当前他的值，和他所连接的节点的数组
```cpp
class Vertex{
public:
	int id;
	vector<Vertex*>nerighbors;
};
```
这和多叉树的结构几乎一模一样，所以其实图就是一个高级一点的多叉树，适用于数的DFS/BFS，搜适用于图

### 度
图论中特有一个**度**的概念

在无向图中，度就是每一个节点相连边的条数。在有向图中，度又被细分为入度和出度

---
上面是逻辑结构上的图，在实际实现过程中，我们常常使用**邻接表**和**领接矩阵**来实现图结构

![](https://pic1.imgdb.cn/item/681b7f8d58cb8da5c8e3dfbe.png)
比如上面的图结构用邻接表和领接矩阵来实现

上述默认图节点是一个从 0 开始的整数，所以才能存储到邻接表和邻接矩阵中，通过索引访问。

但实际问题中，图节点可能是其他类型，比如字符串、自定义类等，那应该怎么存储呢？

很简单，你再额外使用一个哈希表，把实际节点和整数 id 映射起来，然后就可以用邻接表和邻接矩阵存储整数 id 了。

```
注意分析两种存储方式的空间复杂度，对于一幅有 `V` 个节点，`E` 条边的图，邻接表的空间复杂度是 O(V+E)O(V+E)，而邻接矩阵的空间复杂度是 O(V2)O(V2)。

所以如果一幅图的 `E` 远小于 `V^2`（稀疏图），那么邻接表会比邻接矩阵节省空间，反之，如果 `E` 接近 `V^2`（稠密图），二者就差不多了。

在后面的图算法和习题中，大多都是稀疏图，所以你会看到邻接表的使用更多一些。

邻接矩阵的最大优势在于，矩阵是一个强有力的数学工具，图的一些隐晦性质可以借助精妙的矩阵运算展现出来
```

上面我们的图仅仅是有向无权图，不是还有什么加权图，无向图等等

**但其实这些更加复杂的模型都是从这个最简单的模型衍生出来的**

如果是邻接表，我们不仅仅存储某个节点的邻居节点，还存储这个节点到每个邻居的权重，不就成为加权图了吗

如果是领接矩阵，`matrix[x][y]`不再是一个bool值，而是一个int值，0代表没有链接，其他值表示权重，不就成加权有向图了吗

那无向图呢？无向不就相当于都是双向？

