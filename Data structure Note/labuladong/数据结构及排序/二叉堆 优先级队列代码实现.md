### 简化版优先级队列
我们实现的这个简化版优先级队列有如下限制：

1、不支持泛型，仅支持存储整数类型的元素。

2、不考虑扩容的问题，队列的容量在创建时固定，假设插入的元素数量不会超过这个容量。

3、底层仅实现一个小顶堆（即根节点是整个堆中的最小值），不支持自定义比较器。

api如下：
```
class SimpleMinPQ {
public:
    // 创建一个容量为 capacity 的优先级队列
    SimpleMinPQ(int capacity);

    // 返回队列中的元素个数
    int size();

    // 向队列中插入一个元素
    void push(int x);

    // 返回队列中的最小元素（堆顶元素）
    int peek();

    // 删除并返回队列中的最小元素（堆顶元素）
    int pop();
};


// 使用方法
SimpleMinPQ pq(10);
pq.push(3);
pq.push(4);
pq.push(1);
pq.push(2);
cout << pq.pop() << endl; // 1
cout << pq.pop() << endl; // 2
cout << pq.pop() << endl; // 3
cout << pq.pop() << endl; // 4
```

很明显，二叉堆的难点在于**在插入或者删除元素的时候依然保持二叉堆的性质**

#### 增:`push/swim`方法插入元素
核心步骤
以小顶堆为例，向小顶堆中插入新元素遵循两个步骤：

1、先把新元素追加到二叉树底层的最右侧，保持完全二叉树的结构。此时该元素的父节点可能比它大，不满足小顶堆的性质。

2、为了恢复小顶堆的性质，需要将这个新元素不断上浮（`swim`），直到它的父节点比它小为止，或者到达根节点。此时整个二叉树就满足小顶堆的性质了。

二叉堆中的每个节点就是一个经过改造的二叉树节点，除了包含 `left, right, val` 这些属性外，还有一个 `parent` 属性，指向该节点的父节点

```cpp
class Node
{
    public:
    int val;
    Node*left,*right,*parent;
    Node(){}
    Node(int v):val(v),left(nullptr),right(nullptr),parent(nullptr){}
};
class MinHeap
{
    public:
    Node*root;
    vector<Node*>nodes;//用来方便定位二叉树的位置
    MinHeap(vector<int>&vals)
    {
        if(vals.empty())return;
        for(int v:vals)
        {
            insert(v);
        }
    }
    void insert(int value)
    {
        Node*newnode=new Node(value);
        if(nodes.empty())
        {
            root=newnode;
            nodes.push_back(newnode);
            return;
        }
        //插入到完全二叉树的最后 插入和删除操作肯定都得先找到他的父节点
        Node*parent=nodes[(nodes.size()-1)/2];
        if(parent->left==nullptr)
        {
            parent->left=newnode;
        }
        else parent->right=newnode;
        newnode->parent=parent;
        nodes.push_back(newnode);
        swim(newnode);
    }
    void swim(Node *node)
    {
        Node*parent=node->parent;
        while(parent&&parent->val>node->val)
        {
            swap(parent->val,node->val);
            node=parent;
            parent=node->parent;
        }
    }
};
```

首先，我们可以看到节点的定义中多了一个parent指针，这是为了方便找到一个节点的父节点使用的。

其实我们在二叉堆的类中定义了一个数组，因为我们要在这个完全二叉树的末尾添加进新节点，而完全二叉树用数组来存储将会是非常的简单，这时候我们只需要根据索引值就能找到所需要的父节点，然后我们将这个新节点添加进去

之后我们就要进行上浮操作，只要不为根节点并且父节点的值大于当前值，就交换。第一个问题，怎么判断是否为根节点，很简单，parent为nullptr的就是根节点，其次，怎么交换？**比较巧妙的方法是，直接把两个值交换不就得了吗**，所以不要把东西看的太死，不是非要把这两个节点交换，本质上我把这两个值直接交换就达到了一样的效果，**所以本质上是值在上浮**

同时也给了我们一种建堆的方法，那就是把所有的值依次插入进去不就行了，时间复杂度为O(NlogN)

#### 删:pop/sink方法删除元素
以小顶堆为例，删除小顶堆的堆顶元素遵循两个步骤：

1、先把堆顶元素删除，把二叉树底层的最右侧元素摘除并移动到堆顶，保持完全二叉树的结构。此时堆顶元素可能比它的子节点大，不满足小顶堆的性质。

2、为了恢复小顶堆的性质，需要将这个新的堆顶元素不断下沉（`sink`），直到它比它的子节点小为止，或者到达叶子节点。此时整个二叉树就满足小顶堆的性质了。

```cpp
    void pop()
    {
        if(nodes.empty())return;
        Node*last=nodes.back();
        nodes.pop_back();
        if(last==root)
        {
            delete root;
            root=nullptr;
            return;
        }
        root->val=last->val;
        Node*parent=last->parent;
        if(parent->left==last)parent->left=nullptr;
        else if(parent->right==last)parent->right=nullptr;
        delete last;
        sink(root);
    }
    void sink(Node*node)
    {
        while(node)
        {
            Node*smallest=node;
            if(node->left&&node->left->val<smallest->val)smallest=node->left;
            if(node->right&&node->right->val<smallest->val)smallest=node->right;
            if(smallest==node)break;
            swap(smallest->val,node->val);
            node=smallest;
        }
    }
```
删除元素:
首先判断是否有元素，没有直接返回。其次需要注意的是，如果只有一个元素的特殊情况。那么其他情况就是正常将最后一个元素的值移到root，然后需要找到最后一个元素的parent，**别忘了指针处理**，处理完后，让根节点做下沉操作

下沉操作：
我们需要找到左右两个节点中较小的哪一个，也就是找到三个节点中的值最小的节点，如果smallest就是node本身就说明要么为叶子节点要么左右节点的值都比他大，就已经满足了二叉堆的性质了可以结束循环。不然的话交换然后向下依次处理。

#### 查:peak方法查看堆顶元素
直接返回根节点的值就行了

### 用数组模拟二叉树
事实上，我们最好使用数组来模拟二叉树，而不是链表，第一个原因就是内存开销，什么左右子节点父节点都可以直接拿索引的关系来获得，我们只需要存值就可以了
其实就是我们可以直接获得比如最底层最右侧元素，如果完全用链状结构，则需要遍历那么，不管是push还是pop的时间复杂度都退化到了O(n)

**这就解释了为什么二叉堆一定要保持是完全二叉树**

至此我们就基本了解了二叉堆的代码实现，至于完整版的代码和实际真正stl中的代码（包括支持什么泛型、自定义比较器什么的），我们留到mytinystl和stl源码剖析的cpp进阶学习中去学习，这里我们只需简单了解原理，即使自己写，能写出解决题目的代码，能用即可。