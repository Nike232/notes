### 用链表加强哈希表
![](https://pic1.imgdb.cn/item/67f7330c88c538a9b5c83068.jpg)
如果只有这个，我们是得不出元素的插入顺序，而且在触发扩缩容操作的时候，哈希函数得到的哈希值可能又会发生改变，所以仅靠现在是无法实现正常遍历的。

但是注意哈希表只是实现了键值对映射，那其实每一个键值对之间仍然是孤立的，我们把他看做链表当中的节点，那么如果我们用双链表将所有键值对链接起来，不就可以实现遍历了吗？
**为什么选用双链表？**

- 首先，如果要看我们要做的操作是什么，我们需要的是在任意位置进行增加和删除操作。
- 对于查找和修改哈希表已经在o（1）的时间复杂度上做到了。
- 对于中间的节点的删除和插入操作如果是单链表的话就必须要访问到前驱节点，这就要求必须从头遍历，时间复杂度退回到了o(n)。
- 而如果是双链表的话就可以直接在o（1）的复杂度实现，我们之前说o（n）的原因是因为要花时间查找，但是这里哈希表已经帮我们实现了，这跟我们前面说的哈希表+双链表来实现o（1）的中间插入和删除操作是一致的。
- 这就实现了哈希链表的形式，在维护映射的同时，通过双链表维护节点之间的关系。
### 用数组加强哈希表
问题来源于如何随机获得一个哈希表的key（注意这里的随机是平均随机）

很容易的可以想到，数组具有随机的性质，如果所有数组当中都是满的，那么生成一个随机数就可以实现平均随机了。那么根据上面的想法，其实哈希表就只是实现了键值对映射，其节点之间任然是分离的，所以我们完全可以把所有的节点加入到一个数组当中。

但是很明显，只有满的数组能够实现，在结尾删除元素可以维护仍然是满的，但是如果在中间删除元素的话就会造成的数组的空洞，因而我们可以把要删除的节点和数组最后的节点进行交换然后在删除，那么怎么得到一个节点对应的索引呢，最后一个节点很容易只要我们拿到数组的长度就可以了，但是对于中间的呢？如果要遍历得到的话还不如直接迁移数据，那么我们还是采用用空间换时间，让每一个节点维护对应数组的索引就可以了。

但是如果交换了元素，整体的顺序不就被破坏了吗？核心其实在于我们要解决的是随机获得key，而不是遍历，一种数据结构有对应要解决的问题，不存在完美的数据结构。