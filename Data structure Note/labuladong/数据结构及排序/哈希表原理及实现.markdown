## 哈希表原理及实现

### 哈希表原理

* 首先，哈希表和键值映射不是一个东西。键值映射可以通过多种方法实现，哈希表只是其实一种实现方式（哈希函数）
* **哈希表可以理解为加强版的数组**，将key通过哈希函数映射为数组的索引，进而通过这个索引进行增删查改的操作。而数组进行查找和修改，添加和删除的时间复杂度为o（1），这里的操作是针对一个元素而言，强调数组的随机访问能力。因而整体时间复杂度取决于**哈希函数的时间复杂度**。
* key是唯一的，但是value是不唯一的，也就是说建立的是单向映射。同样的key得到的要是相同的value值。这是哈希表的正确性的前提
* 哈希函数：
  * 哈希函数有无数种设计方式，反正就是将输入转化为一个合法的且唯一的索引。具体实现不在我们当前的讨论范围内。
  * 哈希函数的性能决定了整个哈希表的性能

* 哈希冲突：
  * 哈希冲突是指两个相同的key通过哈希函数映射到了同一个索引的现象
  * 哈希冲突是**无法消除的只能尽可能地减少**，原因是哈希函数实际上是将无限映射到了有限的内存当中，比如将整数转换为索引，由于内存的限制，索引值肯定是有限的，但是整个整数是无穷的，所以说哈希冲突是不可避免的
  * 哈希冲突是无法避免的，只有概率问题，如果就是发生了怎么办呢？不可能让整个哈希表作废了。当哈希冲突发生了，有两种解决方法：
    1. 拉链法，也就是整个数组每一个元素装的是链表，因而如果索引值相同也可以通过遍历链表来查找
    2. 开放寻址法，也就是如果计算出的这个索引值如果已经被占用了，那就让索引值加一，直到找到没有没占用的地址
  * 哈希冲突常发生的情况：
    1. 哈希函数设计得不够合理
    2. 当前装的元素已经很多了，比如一百容量的数组，已经装了90个元素了，那么这种情况下，就很容易发生哈希冲突。这种情况我们可以**扩大底层数组的容量来减小哈希冲突发生的概率**

* 注意：**哈希表中键的遍历顺序是无序的**，原因首先是索引是计算出来的，不是顺序分配的，其次是如果当装载的个数到达负载因子之后，会自动扩容，在搬迁数据的过程中会重新计算索引值，又会导致顺序的无序性。
* **只有不可变类型，才能作为哈希表的键**，原因很简单，因为索引是根据键计算出来的，如果键可变的话那么你再去查找的时候，计算出的索引值就不一样了。

### 拉链法实现哈希表

* **主要是添加和修改是统一在一个函数中操作**，如果没有找到就添加，如果找到了就修改。**如果链表不为空的时候，不能直接添加元素，因为有可能已经存在了，所有要确定是否存在**，**这个唯一存储的特性**意味着不是来一个元素就添加，这个是一个键只能对应一个元素，因而，**在添加和修改的时候要先确定是否已经存在**，这也是为什么添加和修改可以统一操作的原因
* 底层节点要存储key 和value两个值，因为在发生哈希冲突的时候需要通过匹配key来唯一确定值