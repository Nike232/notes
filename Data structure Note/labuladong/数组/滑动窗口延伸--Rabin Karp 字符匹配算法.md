首先有一个很基础的问题，输入一个字符串形式的正整数，如何将它转化为数字的形式？
```cpp
#include<iostream>
#include<string>
using namespace std;

int main() {
    string s = "8264";
    int number = 0;
    for (int i = 0; i < s.size(); i++) {
        // 将字符转化成数字
        number = 10 * number + (s[i] - '0');
        cout << number << endl;
    }
    // 打印输出：
    // 8
    // 82
    // 826
    // 8264
    return 0;
}
```
这个代码就能解决，这个算法的核心是不断向末尾添加数字，然后整体左移一位(x10)
那如何删去最高位，比如8264，如何删去一位得到264，很简单，只需要减去8000就可以了，这个8000怎么得到呢?就是8x10^3 ，这个3就是删去后的位数

我们先来看一道题
DNA 序列由四种碱基 `A, G, C, T` 组成，现在给你输入一个只包含 `A, G, C, T` 四种字符的字符串 `s` 代表一个 DNA 序列，请你在 `s` 中找出所有重复出现的长度为 10 的子字符串。

首先最容易想到的解法肯定就是暴力解法，我们用一个哈希集合来存储已经见过的元素，然后遍历所有连续的长度为10的子串，如果已经见过就加入到结果不然的话加入到seen当中，就算是用滑动窗口其实也是一样的时间复杂度，都为O(NL)

优化的关键在于，能不能不真正的生成子字符串，而是用一些其他形式的唯一标识来表示窗口中的子字符串，并且还能够做到在滑动窗口移动的过程中快速更新

 回想开头的两个例子肯定就明白了，我们可以将对应的字符想成对应的数字（就像编码一样），然后这个十位数就是唯一对应的，并且移除最高位的操作和添加末尾的操作刚好对应上了

其实你想下，你把一个字符串对象转化成了一个数字，这是什么？这就是你设计的一个哈希算法，生成的数字就可以认为是字符串的哈希值。**在滑动窗口中快速计算窗口中元素的哈希值，叫做滑动哈希技巧**。

那么再进一步想，根据我们编码的技巧，这里只有4种情况，也就是0123，那其实我们只需要4进制就足够了，不然的话会达到10^10 ，int是存放不下的，必须要用long，这显然是有点浪费的。那对应的进制进行修改就可以了

```java
// ****** 在最低位添加一个数字 ******
// number 的进制
int R = 4;
// 想在 number 的最低位添加的数字
int appendVal = 0~3 中的任意数字;
// 运算，在最低位添加一位
number = R * number + appendVal;

// ****** 在最高位删除一个数字 ******
// number 的进制
int R = 4;
// number 最高位的数字
int removeVal = 0~3 中的任意数字;
// 此时 number 的位数
int L = ?;
// 运算，删除最高位数字
number = number - removeVal * R^(L-1);
```

接下来，进阶到字符匹配，字符匹配我们目前已知的有暴力算法还有KMP算法，根据上面的例子我们还可以用Kabin Karp算法。

**那么借鉴上面的思路，我们不要每次都去一个字符一个字符地比较子串和模式串，而是维护一个滑动窗口，运用滑动哈希算法一边滑动一边计算窗口中字符串的哈希值，拿这个哈希值去和模式串的哈希值比较，这样就可以避免截取子串，从而把匹配算法降低为 O(N)，这就是 Rabin-Karp 指纹字符串查找算法的核心逻辑**。

```cpp
// 文本串
string txt = s;

// 模式串
string pat = t;

// 需要寻找的子串长度为模式串 pat 的长度
int L = pat.length();

// 仅处理 ASCII 码字符串，可以理解为 256 进制的数字
int R = 256;

// 存储 R^(L - 1) 的结果
int RL = pow(R, L - 1);

// 维护滑动窗口中字符串的哈希值
int windowHash = 0;

// 计算模式串的哈希值
long long patHash = 0;
for (int i = 0; i < pat.length(); i++) {
    patHash = R * patHash + pat[i];
}

// 滑动窗口代码框架
int left = 0, right = 0;
while (right < txt.length()) {
    // 扩大窗口，移入字符（在最低位添加数字）
    windowHash = R * windowHash + txt[right];
    right++;

    // 当子串的长度达到要求
    if (right - left == L) {
        // 根据哈希值判断窗口中的子串是否匹配模式串 pat
        if (patHash == windowHash) {
            // 找到模式串，返回起始索引
            return left;
        }

        // 缩小窗口，移出字符（删除最高位数字）
        windowHash = windowHash - txt[left] * RL;
        left++;
    }
}

// 没有找到模式串
return -1;
```

**不过代码在运行过程中会有一个严重的问题，那就是整型溢出**,因为我们这里是256进制的数，这个数量级是超级大的

**所以解决方法是什么呢？如何把一个很大的数映射到一个较小的范围呢**

答案是取模，这也是哈希表原理中讲过的。

无论一个数字多大，你让它除以 `Q`，余数一定会落在 `[0, Q-1]` 的范围内。所以我们可以设置一个 `Q`，用求模的方式让 `windowHash` 和 `patHash` 保持在 `[0, Q-1]` 之间，就可以有效避免整型溢出。

但是与之而来的也是跟哈希表一样的问题，那就是哈希冲突，最后取模的结果一样不代表原本的两个数就是一样的

对于 Rabin-Karp 算法来说，当发现 `windowHash == patHash` 时，使用暴力匹配算法检查一下窗口中的字符串和 `pat` 是否相同就可以避免哈希冲突了。因为希冲突出现的概率比较小，所以偶尔用一下暴力匹配算法是不影响总体的时间复杂度的。

取模的运算法则：
```
X % Q == (X + Q) % Q
(X + Y) % Q == (X % Q + Y % Q) % Q
```

代码：
```
// Rabin-Karp 指纹字符串查找算法
int rabinKarp(string txt, string pat) {
    // 位数
    int L = pat.length();
    // 进制（只考虑 ASCII 编码）
    int R = 256;
    // 取一个比较大的素数作为求模的除数
    long Q = 1658598167;
    // R^(L - 1) 的结果
    long RL = 1;
    for (int i = 1; i <= L - 1; i++) {
        // 计算过程中不断求模，避免溢出
        RL = (RL * R) % Q;
    }
    // 计算模式串的哈希值，时间 O(L)
    long patHash = 0;
    for (int i = 0; i < pat.length(); i++) {
        patHash = (R * patHash + pat.at(i)) % Q;
    }

    // 滑动窗口中子字符串的哈希值
    long windowHash = 0;

    // 滑动窗口代码框架，时间 O(N)
    int left = 0, right = 0;
    while (right < txt.length()) {
        // 扩大窗口，移入字符
        windowHash = ((R * windowHash) % Q + txt.at(right)) % Q;
        right++;

        // 当子串的长度达到要求
        if (right - left == L) {
            // 根据哈希值判断是否匹配模式串
            if (windowHash == patHash) {
                // 当前窗口中的子串哈希值等于模式串的哈希值
                // 还需进一步确认窗口子串是否真的和模式串相同，避免哈希冲突
                if (pat.compare(txt.substr(left, L)) == 0) {
                    return left;
                }
            }
            // 缩小窗口，移出字符
            windowHash = (windowHash - (txt.at(left) * RL) % Q + Q) % Q;
            // X % Q == (X + Q) % Q 是一个模运算法则
            // 因为 windowHash - (txt[left] * RL) % Q 可能是负数
            // 所以额外再加一个 Q，保证 windowHash 不会是负数

            left++;
        }
    }
    // 没有找到模式串
    return -1;
}
```
最后说一下这个大素数 `Q` 的选择。

**为什么要这个 `Q` 尽可能大呢？主要是为了降低哈希冲突的概率**。

因为代码中你把这个 `Q` 作为除数，余数（哈希值）一定落在 `[0, Q-1]` 之间，所以 `Q` 越大，哈希值的空间就越大，就越不容易出现哈希冲突，整个算法的效率就会高一些。

**为什么这个 `Q` 要是素数呢？依然是为了降低哈希冲突的概率**。

举个极端一点的例子，你令 `Q = 100`，那么无论一个数 `X` 再大，`X % Q` 的结果必然是 `X` 的最后两位。换句话说 `X` 前面的那些位你根本没利用，可想而知你这个哈希算法存在某些规律性，不够随机，进而更容易导致哈希冲突，降低算法的效率。

而如果你把 `Q` 设置为一个素数，可以更充分利用被除数 `X` 的每一位，得到的结果更随机，哈希冲突的概率更小。这个结论是能够在数学上证明的，有兴趣的读者可以自行搜索学习，我这里就不展开了。