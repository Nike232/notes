滑动窗口本质上还是快慢指针，在两个指针之间的就是窗口，滑动窗口常常用来解决子数组问题，比如让你查找符合某个条件的最长或者最短子数组。时间复杂度为O(n)

算法框架如下：
```cpp
// 滑动窗口算法伪码框架
void slidingWindow(string s) {
    // 用合适的数据结构记录窗口中的数据，根据具体场景变通
    // 比如说，我想记录窗口中元素出现的次数，就用 map
    // 如果我想记录窗口中的元素和，就可以只用一个 int
    auto window = ...

    int left = 0, right = 0;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        window.add(c);
        // 增大窗口
        right++;

        // 进行窗口内数据的一系列更新
        ...

        // *** debug 输出的位置 ***
        printf("window: [%d, %d)\n", left, right);
        // 注意在最终的解法代码中不要 print
        // 因为 IO 操作很耗时，可能导致超时

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            window.remove(d);
            // 缩小窗口
            left++;

            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

最核心的问题在于：
1. 什么时候扩大窗口？
2. 什么时候缩小窗口？
3. 什么时候更新值？

### 将x减0的最小操作数
给你一个整数数组 `nums` 和一个整数 `x` 。每一次操作时，你应当移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值。请注意，需要 **修改** 数组以供接下来的操作使用。

如果可以将 `x` **恰好** 减到 `0` ，返回 **最小操作数** ；否则，返回 `-1` 。

这道题乍一看和滑动窗口没什么关系，但是仔细想也就是去掉两端的元素和为x，那么剩下的也就是sum-x，而这是一个定值，于是问题就转化成了求最长和为定值的子数组的长度，这就变成了滑动窗口的问题,还要注意一个细节就是这道题能用滑动窗口的前提是所有数都是正数，也就是**滑动窗口的状态是能确定的**，进入窗口，值一定变大，离开窗口，值一定变小，如果值可以是负数的话，则不能用滑动窗口

下面看一个错误的代码
```cpp
    int minOperations(vector<int>& nums, int x) {
        int sum=0;for(int n:nums)sum+=n;
        int target=sum-x;
        int left=0,right=0,len=-1;
        int window=0;
        while(right<nums.size())
        {
            int a=nums[right];
            right++;
            window+=a;
            while(window>=target)
            {
                if(window==target)len=max(len,right-left);
                int b=nums[left];
                left++;
                window-=b;
            }
        }
        return  len==-1?-1:nums.size()-len;
    }
```

从整体上来讲大概思路是没有问题的，那么这种时候一般都是边界处理出现了问题，**就要列出几种可能的极端情况进行排查**
1. x<sum，是没有问题的
2. x=sum，出现了问题，比如1,2的数组,x为3，那么那么target应该为0，先把1加入进来,window=1,>=0缩小窗口，window=0再进入窗口，发现这个时候left=2了>right，这很明显是错误的，也就是说至少要限制一个条件left<right,所以==第一个修改的地方就是加上left<right的限制条件==。现在我们再来分析，一开始为1进入循环，执行一次，left=1,right=1,不执行，这个时候window=0,然后是2，执行，最后window=0,但是没有执行相等判断，本来应该返回2但是返回了-1，也就是如果为0的话将无法判断，因而==第二个修改是将相等判断条件移到while下面同时while里面的>=改为>==
3. x>sum,一样的问题while会一直执行导致溢出，同上修改。
实际上是确定错了什么时候该更新值，等于的时候不应该缩小窗口，应该是值变大了缩小窗口，然后再确定小于等于的时候判断并更新值，再注意一下x不确定，所以有一定的限制条件

### 替换后的最长重复字符
给你一个字符串 `s` 和一个整数 `k` 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 `k` 次。

在执行上述操作后，返回 _包含相同字母的最长子字符串的长度。_

扩大窗口的时候，我们肯定得需要知道这个窗口内出现次数最多的字符的个数，那么剩下需要替换的个数就是right-left-maxcount,如何知道这个窗口当中的出现次数最多的字符的个数呢？我们可以用一个数组来存储每个字符出现的次数，然后用一个maxcount及时更新值，那么如何获得maxcount呢？直接遍历找最大值吗？这当然是一种解法，我们学习一种比较高级的解法
```cpp
class Solution {
public:
    int characterReplacement(string s, int k) {
        int left = 0, right = 0;
        // 统计窗口中每个字符的出现次数
        vector<int> windowCharCount(26, 0);
        // 记录窗口中字符的最多重复次数
        // 记录这个值的意义在于，最划算的替换方法肯定是把其他字符替换成出现次数最多的那个字符
        int windowMaxCount = 0;
        // 记录结果长度
        int res = 0;

        // 开始滑动窗口模板
        while (right < s.length()) {
            // 扩大窗口
            int c = s[right] - 'A';
            windowCharCount[c]++;
            windowMaxCount = max(windowMaxCount, windowCharCount[c]);
            right++;

            // 这个 while 换成 if 也可以
            while (right - left - windowMaxCount > k) {
                // 杂牌字符数量 right - left - windowMaxCount 多于 k
                // 此时，k 次替换已经无法把窗口内的字符都替换成相同字符了
                // 必须缩小窗口
                windowCharCount[s[left] - 'A']--;
                left++;
            }
            // 经过收缩后，此时一定是一个合法的窗口
            res = max(res, right - left);
        }
        return res;
    }
};
```
1. 为什么换成if也可以？
2. 为什么缩小窗口时没有更新windowMaxCount的值
3. 为什么windowMaxCount的值更新是这样的？
先说结论，结论是从严格意义上来讲，确实是错误的，但是并不影响答案。这里的maxcount并不是每个时刻窗口的最大值，而是历史最大值，也就是说maxcount只增不减（乐观值），这样会导致是否为合法窗口的判断会有错误，但是对于最后结果的值是没有影响的。

因为最后要获得的值是长度，而不是具体的那一段，在每一次更新maxcount的时候（这时候得到的是确实是真实值），那么之后只要不更新maxcount的值，res的值就不会更新，while循环同时也保证了题目的合法性，这种合法性是我最好估计的情况也就是最可能最大的情况，并不是每一个情况都会估计错误，但是在涉及到res更新的情况就一定是正确的，而后面我们就按照历史最大来乐观估计。

这可能比较抽象，我们列举几种情况

第一种，maxcount更新了，但是没有执行while循环，也就是还没消耗完可用值，后面right++，我们假设maxcount没有变，也就是加进来的都是无效值会占用可用值，直到触发缩小窗口，然后更新res。这时候就是res在这个maxcount的情况下的最大值了。为什么？我们考虑后面再加进来的值，加入无效值，那还是会触发while,整个窗口的大小没有改变，而如果是有效值，那么可能会触发maxcount更新

第二种，maxcount一更新，然后执行了while循环，那么更新res,后面一样的道理，加进来无效值窗口大小不变，res不可能更新，加进来有效值，可能会更新maxcount(取决于缩小时删除的值的类型)，就算没有更新，那不就相当于平移嘛，这已经是最好的结果

总而言之就是，对于历史最大值，最好的结果也不过是res上次更新时情况的平移，因为其实已经最优了，所以可以这样处理，大大提高了效率，同时也是符合竞赛只需要管输出的思想

至于为什么可以改为if,很简单因为每次最多加进来一个无效值，也就是最多比k多一，left++了肯定就不可能再循环了。

### 存在重复元素II
给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

我们维护一个窗口，这个窗口的要求是大小小于等于k,因而缩小窗口的条件就出来了，也就是当窗口大小大于k的时候缩小窗口，那我们要做的就是在这个窗口里面看有没有重复的元素，因而我们用了一个哈希表来存储，每次扩大窗口的时候，都看一看已经新加入的值有没有和窗口里面相同的,注意准确来说是在扩大窗口之前，因为要求i!=j,所以如果先扩大，在判断加入的有无相同的，那就一定有相同的了。

### 存在重复元素III
给你一个整数数组 `nums` 和两个整数 `indexDiff` 和 `valueDiff` 。

找出满足下述条件的下标对 `(i, j)`：

- `i != j`,
- `abs(i - j) <= indexDiff`
- `abs(nums[i] - nums[j]) <= valueDiff`

如果存在，返回 `true` _；_否则，返回 `false` 。

我们还是延续之前的思路，在窗口大小大于indexDiff的时候缩小窗口，问题的关键在于如何找到窗口中的某个值满足条件，当然直接遍历是最暴力的思路，但是时间复杂度会很高很高，我们就要结合实际需要的东西进行分析，我们只需要满足abs<=某个值，我们已经有一个元素是确定的了，那么问题其实转化成了我们能不能再简短时间内拿到窗口内里这个元素最近的值，这两个差肯定是所有情况中最小的，如果这都不满足，那就是没有，反之就有。只让我们想到了二叉搜索树。

cpp中的set便是一个基于红黑树实现的有序关联容器，也就是说我们插入一个值进去，他能自动排序，而我们知道红黑树是一种自平衡的二叉搜索树，所以查找的时间复杂度为O(logn)

所以我们只需要利用lower_bound(value)函数（返回一个不小于value元素的迭代器）然后进行处理就可以了

记住int的范围为`-2^31-2^31-1`，2^31 ≈**2x*10^9**

```cpp
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {
        set<int>window;
        int left=0,right=0;
        while(right<nums.size())
        {
            auto close=window.lower_bound(nums[right]);
            if(close!=window.end()&&*close-nums[right]<=valueDiff)return true;
            if(close!=window.begin())
            {
                close--;
                if(nums[right]-*close<=valueDiff)return true;
            }
            window.insert(nums[right]);
            right++;
            if(right-left>indexDiff)
            {
                window.erase(nums[left]);
                left++;
            }
        }
        return false;
    }
};
```
对于我们任一一个需要判断的nums[right]而言，我们首先通过lower_bount找到与他最相近的大于等于的值，然后如果存在且符合条件，返回true，不存在就直接不管，然后我们找距离他最相近的小于的值，只要迭代器不是window.begin()（这意味着没有比它更小的值）那么这个值的迭代器其实就是刚才大于等于的值的迭代器--然后正常判断即可

|   |   |
|---|---|
|`lower_bound(value)`|返回第一个不小于 `value` 的元素的迭代器|

|   |   |
|---|---|
|`upper_bound(value)`|返回第一个大于 `value` 的元素的迭代器|

返回第一个小于的话，要用lower_bound返回的迭代器往前减一，当然得先进行判断