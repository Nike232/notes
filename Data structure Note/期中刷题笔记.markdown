## 期中刷题笔记

* Luogu 栈模板

  ![image-20250329105105378](/Users/tomfng/Library/Application Support/typora-user-images/image-20250329105105378.png)

题目本身相当简单，没有通过测评的原因是没有仔细阅读题目，一定要注意数据规模！！！显然2的64次方应该使用unsigned long long 然后考虑到链表的实现比数组要复杂，虽然我们说链表的好处在于不用考虑上溢出，这样就可以满足题目的所有数据的要求，但是，题目一般都是有最大数据规模的！！！所以技巧是**能用数组实现模拟的就直接拿数组模拟**因为链表涉及到指针操作比较复杂也比较容易出错，其次因为oj题目都是黑盒测试所以除非必须要求用链表都可以用大数组来实现

* Luogu 

![image-20250329202754317](/Users/tomfng/Library/Application Support/typora-user-images/image-20250329202754317.png)

这道题是一个极好的题目，蕴含了很多思想也隐藏了很多容易出错的地方！一定要重点掌握。首先我们肯定不会傻乎乎地直接用队列来模拟，这很显然就是直接用链表来处理，里面包含了很多很多的插入和删除操作，按照之前笔记总结出来的就应该使用双链表加哈希表的方法。好了这里又分成了两个方法，我们就不妨先从最容易理解的直接使用双链表，但是我们会遇到一个问题，就是这个哈希表的第二个值我们本来是想取节点直接的位置的，那么如果用自带的list发现是很难做到的，如果只是单纯记录次序的话不仅很难维护而且又回到了很大的复杂度。那么我们就只能自己写一个双链表了然后哈希表的第二个值就直接用node*，但是一般我们双链表的插入和删除操作都是直接在头部和尾部进行操作的，在中间进行操作就要结合上哈希表，而且在头部和尾部操作也基本没用上。所以虽然这个是可行的，但是麻烦而且很多用不上只是封装性比较好。我们在解决题目的时候要有一个思想，那就是我们不是在写底层的数据结构而是**就题解题**，下面我们看一下，力扣对链表的定义

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
```

然后我们在解决问题也就是写solution的时候不就是只拿到了这样一个指针嘛，**所以对于这种根本用不上某种数据结构的原生api的或者用的很少的，与其写出数据结构然后写对应的实现函数，还不如直接拿节点，一边写数据结构一边解决问题，相当于写出解决这个问题的数据结构**这就是就题解题，所以之后的我们也可以效仿力扣，**要用上原生api的就直接用stl，不准用的话就自己写，其他情况下都可以像力扣那样解题**

明白了这个之后还有很多要注意的地方，这也是通用的一些容易出错的地方，比如**忘记更新、边界情况没有考虑**这道题容易出错的点在于1.map在删除元素后忘记erase 2.在左侧添加元素，要动用->pre->next 那么pre是否是nullptr 同样在右侧添加元素的时候->next是否可能为nullptr 3.在删除元素更新的时候同样的道理nullptr的问题，4.dummy.next没有更新

这些并非是算法思想上的问题，更多是小的细节习惯上的问题，但是往往就是这些问题导致程序无法正常运行。所以一定要养成良好的编程习惯。1.写代码，在干什么一定要清楚 2.需要更新的值在定义的时候就写下来记住要更新值 3.先考虑整体问题肯定是没有问题的，但是也不能忘记边界情况的考察

* **链表最容易出错的地方：忘记更新链表！！！一定要注意！**

* 