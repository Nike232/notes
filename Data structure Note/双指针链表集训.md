## 双指针链表集训

**指针是用来遍历链表的**

双指针有如下几种情形:

1. 有两个链表，分别来遍历这两个链表
2. 一个链表，分别遍历这一个链表

关键点在于：==什么时候移动指针==

* 必会的一个技巧是**虚拟头节点**，也就是将首节点和其他节点平等看待，避免特殊情况的讨论，在创建一个新的链表的时候先定义一个虚拟头节点
* 要注意虚拟头节点是一个**节点**不是一个指针！！！这样会未初始化造成野指针！！！
* 此外==不要把指针当作节点！！！==指针只是指向节点的地址

题目:
1.合并两个有序链表：不必多讲

2.分隔链表：将小于x的节点放在大于等于x的节点之前，要保证相对顺序不变

基本思路遍历：然后分割两个链表然后最后连起来，注意在处理的过程中及时保留下一个节点的地址和断开下一个节点

3.**找到单链表的倒数第k的节点**:
链表不像数组，它的长度是未知的，正向找元素是比较简单的，但是逆向找就得使用这个技巧了

先让一个指针走k步走完之后另外一个指针出发然后两个同时走，当先出发的指针走到头的时候后出发的指针就刚好走到倒数第K个节点（其实也就是正数n-1-k个节点，只是总数不知道罢了）

4.删除倒数第k个节点，那么就是在上面的基础上进行改进，我们说==删除某一个节点一定要先找到它的前驱节点和保存它的后驱节点==才行，注意最好创建一个虚拟头节点，因为有可能要删除的是首节点，那么就找不到前驱节点，需要单独讨论，所以可以用虚拟头节点来避免将首节点一般化进而避免讨论。ps：从首节点和头节点开始的效果是一样的。

5.单链表的中点：还是一样的道理，一个指针走两步一个指针走一步

6.**判断链表中是否包含有环**

借用5的思想如果fast能正常走到最后说明没有，如果走着走着和slow相遇了说明有环

7.如果含有环返回环的起点：

首先肯定还是快慢指针的思路，关键点在于fast走的路程始终是slow走的路程的2倍，所以当两者相遇的时候，假如slow走了k,那么fast走了2k,那么fast比slow多走的k是在环中走的，所以k是环的长度的整数倍。很显然两个指针相遇的地方肯定在环内，那我们将环的起点和相遇点之间的距离设为m,那么首节点到环起点的距离就是k-m与此同时环剩下的距离也是k-m所以只需要将一个指针调回到起点然后两个同步前进，再次相遇的时候就刚好是环起点的位置

8.**相交链表** 

即两个链表的next指向了同一个节点就叫做相交链表，我们还是用两个指针，如果是相交链表的话那么后面相交的部分应该完全相同，也就是在后面存在完全相同的指针，所以主要的问题是由于链表的长度是不知道的，所以两个指针的移动是不同步的，所以可以有一个最基本的想法，先把两个链表的长度求出来，然后将两个链表的遍历指针都移动到相对最后的相同的距离（也就是较小的链表的长度）这个时候移动指针就是同步的了然后比较是否有相同的指针即可

然后稍微改进一下，链表A和B的前面部分是不一样的，如果A遍历完了然后去遍历B，B指针遍历完了B然后去遍历A那么两个指针都会遍历A和B的前半部分这样然后刚好进入相同的部分就保证了两个指针同步进入相同部分然后比较即可

9.删除一个有序链表中所有的重复元素

解法1：和之前的分解链表一样，创建两条新的链表然后遍历一遍分类最后返回

解法2：**类比数组的快慢指针**,精髓在于让慢指针指向最近一个的元素然后快指针如果遇到了与慢指针值相同的就跳过，那么同样我们可以让两个指针都先指向首元素，那么为了一般化其实我们可以定于一个虚拟头节点然后把它的值设置为不可能取到的值，然后快指针指向头节点，这样就实现了首节点的一般化。然后如果快指针找到与慢指针值相同的就跳过，如果找到了不同的就把慢指针的next指向快指针，然后快指针继续往前走，（注意断开与原来下一个节点的关系）,

**难点在于这道题要求如果有重复的元素那么这个元素都不保留**如果是删去多余的元素那么基本和数组的快慢指针完全一样（除了虚拟头节点有点变化），那么也就是说如果当跳过了变成了fast->val!=fast->next->val的时候还不能直接将slow指针进行操作，要将这个时候fast是之前重复元素的最后一个剩余的元素那么还要将fast前进一个，然后判断此时的fast是否和下一个节点相等才行

==本质上来看==，如果是fast!=slow这样的操作那么slow将获得的是整个重复元素的第一个数，如果是fast!=fast->next这样的操作，那么slow得到的就是重复元素的最后一个，如果是保留一个的话那么这两个方法都可以，但是如果都要删除的话就只能用第二个方法，因为第一个只能保证是新的节点不能保证是不重复的，在未知的条件下就直接赋值了，那么第二个方法也要注意要跳过所有的重复元素走到新的元素再来进行判断

解法3:

用递归来解决，basecase如果head为null或者head->next==null直接返回,如果head与后面的值不一样的话，那么直接对后面的去重结果连接起来即可，如果相同的话，跳过重复元素

10.两数相加：给了两个链表分别代表两个整数（逆序排列）返回和的结果链表,跟数组模拟整数加法是一样的，而已已经是逆序了直=直接模拟并保存进位即可。注意**更新进位的时机**避免值已经更新了才更新进位，然后就是**注意最后可能进位不为1**注意判断，如果进位不为0，说明还需要补一位

==常见可能出现的问题==：

1. 如果编译出问题，大概率指针访问了null
2. 如果最后输出的元素只有一个或者很少，大概率就是忘记更新指针
3. 如果只有一个测试没有通过，大概率是边界问题出错
4. 如果只通过了一个或很少测试，大概率是整体思路或者题目某一要求没有看到或者是理解出错，但是整的大方向没有问题
