### **快速取模（Modular Arithmetic）介绍**
快速取模是一种在计算过程中**避免大数溢出**、**提高运算效率**的方法，特别适用于涉及**大数乘法、指数运算、递推**等情况。其核心思想是**在每一步计算时都对结果取模**，避免中间结果变得过大。

---

## **📌 为什么需要快速取模？**
在计算大数时，如果直接执行运算，可能会遇到：
1. **溢出问题**：例如 \( 10^9 \times 10^9 = 10^{18} \)，超过 `long long` 存储范围。
2. **计算速度慢**：如果直接计算 \( a^b \)，指数增长的结果会导致极高的计算复杂度。

因此，我们使用取模运算来限制数值的增长，使得计算量减少，并且不会超过 `long long` 的范围。

---

## **📌 取模运算的基本性质**
模运算 \( \mod M \) 具有以下几个重要性质：
1. **加法取模**：
   \[
   (a + b) \mod M = [(a \mod M) + (b \mod M)] \mod M
   \]
   ✅ **避免溢出**，比如：
   ```cpp
   long long sum = (a % M + b % M) % M;
   ```
   
2. **减法取模**：
   \[
   (a - b) \mod M = [(a \mod M) - (b \mod M) + M] \mod M
   \]
   ✅ 确保结果非负（取模后可能出现负数）。

3. **乘法取模**：
   \[
   (a \times b) \mod M = [(a \mod M) \times (b \mod M)] \mod M
   \]
   ✅ **防止溢出**，比如：
   ```cpp
   long long product = (a % M * b % M) % M;
   ```
   
4. **幂运算取模（快速幂）**：
   \[
   (a^b) \mod M
   \]
   ✅ **使用快速幂算法（O(log b)）**
   ```cpp
   long long mod_pow(long long a, long long b, long long M) {
       long long res = 1;
       while (b > 0) {
           if (b % 2 == 1) // 如果 b 是奇数
               res = (res * a) % M;
           a = (a * a) % M;
           b /= 2;
       }
       return res;
   }
   ```
   🚀 **比普通幂运算（O(b)）快得多！**

---

## **📌 示例：快速求解大数和平方**
假设我们要计算：
\[
S(n) = \left( \frac{n(n+1)}{2} \right)^2 \mod 10000
\]

### **⚠️ 直接计算的问题**
1. \( n \) 可能接近 **10^9**，\( S(n) \) 会远超 `long long` 存储范围。
2. 需要用 **取模运算优化** 来避免溢出。

### **✅ 取模优化计算**
```cpp
#include <iostream>
using namespace std;

typedef long long ll;

int main() {
    ll n;
    while (cin >> n) {
        ll mod = 10000; // 只保留后四位
        ll sum = (n * (n + 1) / 2) % mod; // 先计算 n(n+1)/2 并取模
        sum = (sum * sum) % mod; // 再平方并取模
        printf("%04lld\n", sum); // 输出补零
    }
    return 0;
}
```

**优化点：**
- **(1) 先取模**：\( (n(n+1)/2) \mod 10000 \) 避免数值过大。
- **(2) 再平方取模**：\((sum \times sum) \mod 10000\)，防止 `long long` 溢出。

---

## **📌 总结**
| **方法** | **作用** | **时间复杂度** |
|----------|---------|--------------|
| **加法取模** \( (a+b) \mod M \) | 防止溢出 | O(1) |
| **乘法取模** \( (a \times b) \mod M \) | 避免乘法溢出 | O(1) |
| **快速幂** \( (a^b) \mod M \) | 高效计算幂取模 | O(log b) |
| **取模优化公式** | 用数学公式减少计算量 | O(1) |

📌 **快速取模** 在算法竞赛、密码学、数论计算等场景都非常重要，能大幅优化计算速度 🚀